import sys
import multiprocessing
import warnings
import numpy as np

from photutils.psf import DAOGroup
from photutils.background import MMMBackground
from photutils.psf import BasicPSFPhotometry, IntegratedGaussianPRF

from astropy.modeling.fitting import LevMarLSQFitter
from astropy.modeling import Fittable2DModel, Parameter
from astropy.stats import SigmaClip, gaussian_fwhm_to_sigma
from astropy.table import Table

import hipercam as hcam
from hipercam import cline, utils, spooler
from hipercam.cline import Cline
from hipercam.reduction import (
    Rfile,
    initial_checks,
    update_plots,
    ProcessCCDs,
    setup_plots,
    setup_plot_buffers,
    LogWriter,
    moveApers,
)

# get hipercam version to write into the reduce log file
from pkg_resources import get_distribution, DistributionNotFound

try:
    hipercam_version = get_distribution("hipercam").version
except DistributionNotFound:
    hipercam_version = "not found"

__all__ = [
    "psf_reduce",
]

NaN = float('NaN')

#####################################################################
#
# psf_reduce -- reduces multi-CCD imaging photometry with PSF fitting
#
#####################################################################
def psf_reduce(args=None):
    """``psf_reduce [source] rfile (run first twait tmax | flist) log lplot implot
    (ccd nx msub xlo xhi ylo yhi iset (ilo ihi | plo phi))``

    Performs PSF photometry on a sequence of multi-CCD images, plotting
    lightcurves as images come in. It performs PSF photometry on specific
    targets, defined in an aperture file using |psf_setaper| or |setaper|.

    Aperture repositioning is identical to |reduce|, and the PSF used in photometry
    is set by fitting well separated reference stars. For the best results, a
    suitable strategy is to only reduce data from a small window near the target.
    Set well separated bright stars as reference apertures and link fainter, or
    blended objects to the references.

    |psf_reduce| can source data from both the ULTRACAM and HiPERCAM servers, from
    local 'raw' ULTRACAM and HiPERCAM files (i.e. .xml + .dat for ULTRACAM, 3D
    FITS files for HiPERCAM) and from lists of HiPERCAM '.hcm' files. If you
    have data from a different instrument you should convert into the
    FITS-based hcm format.

    |psf_reduce| is primarily configured from a file with extension ".red". This
    contains a series of directives, e.g. to say how to re-position the apertures.
    An initial reduce file is best generated with the script |genred| after you
    have created an aperture file. This contains lots of help on what to do.

    A |psf_reduce| run can be terminated at any point with ctrl-C without doing
    any harm. You may often want to do this at the start in order to adjust
    parameters of the reduce file.

    Parameters:

        source : string [hidden]
           Data source, five options:

             |  'hs': HiPERCAM server
             |  'hl': local HiPERCAM FITS file
             |  'us': ULTRACAM server
             |  'ul': local ULTRACAM .xml/.dat files
             |  'hf': list of HiPERCAM hcm FITS-format files

           'hf' is used to look at sets of frames generated by 'grab' or
           converted from foreign data formats.

        rfile : string
           the "reduce" file, i.e. ASCII text file suitable for reading by
           ConfigParser. Best seen by example as it has many parts. Generate
           a starter file with |genred|.

        run : string [if source ends 's' or 'l']
           run number to access, e.g. 'run034'

        first : int [if source ends 's' or 'l']
           exposure number to start from. 1 = first frame; set = 0 to
           always try to get the most recent frame (if it has changed)

        last : int [if source ends 's' or 'l', hidden]
           last frame to reduce. 0 to just continue until the end.  This is
           not prompted for by default and must be set explicitly.  It
           defaults to 0 if not set. Its purpose is to allow accurate
           profiling tests.

        twait : float [if source ends 's'; hidden]
           time to wait between attempts to find a new exposure, seconds.

        tmax : float [if source ends 's'; hidden]
           maximum time to wait between attempts to find a new exposure,
           seconds.

        flist : string [if source ends 'f']
           name of file list

        log : string
           log file for the results

        tkeep : float
           maximum number of minutes of data to store in internal buffers, 0
           for the lot. When large numbers of frames are stored, performance
           can be slowed (although I am not entirely clear why) in which case
           it makes sense to lose the earlier points (without affecting the
           saving to disk). This parameter also gives operation similar to that
           of "max_xrange" parameter in the ULTRACAM pipeline whereby just
           the last few minutes are shown.

        lplot : bool
           flag to indicate you want to plot the light curve. Saves time not
           to especially in high-speed runs.

        implot : bool
           flag to indicate you want to plot images.

        ccd : string [if implot]
           CCD(s) to plot, '0' for all, '1 3' to plot '1' and '3' only, etc.

        nx : int [if implot]
           number of panels across to display.

        msub : bool [if implot]
           subtract the median from each window before scaling for the
           image display or not. This happens after any bias subtraction.

        xlo : float [if implot]
           left-hand X-limit for plot

        xhi : float [if implot]
           right-hand X-limit for plot (can actually be < xlo)

        ylo : float [if implot]
           lower Y-limit for plot

        yhi : float [if implot]
           upper Y-limit for plot (can be < ylo)

        iset : string [if implot]
           determines how the intensities are determined. There are three
           options: 'a' for automatic simply scales from the minimum to the
           maximum value found on a per CCD basis. 'd' for direct just takes
           two numbers from the user. 'p' for percentile dtermines levels
           based upon percentiles determined from the entire CCD on a per CCD
           basis.

        ilo : float [if implot and iset='d']
           lower intensity level

        ihi : float [if implot and iset='d']
           upper intensity level

        plo : float [if implot and iset='p']
           lower percentile level

        phi : float [if implot and iset='p']
           upper percentile level
    """

    command, args = utils.script_args(args)

    with Cline("HIPERCAM_ENV", ".hipercam", command, args) as cl:

        # register parameters
        cl.register("source", Cline.GLOBAL, Cline.HIDE)
        cl.register("rfile", Cline.GLOBAL, Cline.PROMPT)
        cl.register("run", Cline.GLOBAL, Cline.PROMPT)
        cl.register("first", Cline.LOCAL, Cline.PROMPT)
        cl.register("last", Cline.LOCAL, Cline.HIDE)
        cl.register("twait", Cline.LOCAL, Cline.HIDE)
        cl.register("tmax", Cline.LOCAL, Cline.HIDE)
        cl.register("flist", Cline.LOCAL, Cline.PROMPT)
        cl.register("log", Cline.GLOBAL, Cline.PROMPT)
        cl.register("tkeep", Cline.GLOBAL, Cline.PROMPT)
        cl.register("lplot", Cline.LOCAL, Cline.PROMPT)
        cl.register("implot", Cline.LOCAL, Cline.PROMPT)
        cl.register("ccd", Cline.LOCAL, Cline.PROMPT)
        cl.register("nx", Cline.LOCAL, Cline.PROMPT)
        cl.register("msub", Cline.GLOBAL, Cline.PROMPT)
        cl.register("iset", Cline.GLOBAL, Cline.PROMPT)
        cl.register("ilo", Cline.GLOBAL, Cline.PROMPT)
        cl.register("ihi", Cline.GLOBAL, Cline.PROMPT)
        cl.register("plo", Cline.GLOBAL, Cline.PROMPT)
        cl.register("phi", Cline.LOCAL, Cline.PROMPT)
        cl.register("xlo", Cline.GLOBAL, Cline.PROMPT)
        cl.register("xhi", Cline.GLOBAL, Cline.PROMPT)
        cl.register("ylo", Cline.GLOBAL, Cline.PROMPT)
        cl.register("yhi", Cline.GLOBAL, Cline.PROMPT)

        # get inputs
        source = cl.get_value(
            "source",
            "data source [hs, hl, us, ul, hf]",
            "hl",
            lvals=("hs", "hl", "us", "ul", "hf"),
        )

        # set some flags
        server_or_local = source.endswith("s") or source.endswith("l")

        # the reduce file
        rfilen = cl.get_value(
            "rfile", "reduce file", cline.Fname("reduce.red", hcam.RED)
        )
        try:
            rfile = Rfile.read(rfilen)
        except hcam.HipercamError as err:
            # abort on failure to read as there are many ways to get reduce
            # files wrong
            print(err, file=sys.stderr)
            exit(1)

        if server_or_local:
            resource = cl.get_value("run", "run name", "run005")
            first = cl.get_value("first", "first frame to reduce", 1, 0)
            cl.set_default("last", 0)
            last = cl.get_value("last", "last frame to reduce", 0, 0)
            if last and last < first:
                print("Cannot set last < first unless last == 0")
                print("*** psf_reduce aborted")
                exit(1)

            twait = cl.get_value(
                "twait", "time to wait for a new frame [secs]", 1.0, 0.0
            )
            tmx = cl.get_value(
                "tmax", "maximum time to wait for a new frame [secs]", 10.0, 0.0
            )

        else:
            resource = cl.get_value(
                "flist", "file list", cline.Fname("files.lis", hcam.LIST)
            )
            first = 1
            last = 0

        log = cl.get_value(
            "log",
            "name of log file to store results",
            cline.Fname("reduce.log", hcam.LOG, cline.Fname.NEW),
        )

        tkeep = cl.get_value(
            "tkeep",
            "number of minute of data to" " keep in internal buffers (0 for all)",
            0.0,
            0.0,
        )

        lplot = cl.get_value("lplot", "do you want to plot light curves?", True)

        implot = cl.get_value("implot", "do you want to plot images?", True)

        if implot:

            # define the panel grid. first get the labels and maximum
            # dimensions
            ccdinf = spooler.get_ccd_pars(source, resource)

            nxdef = cl.get_default("nx", 3)

            if len(ccdinf) > 1:
                ccd = cl.get_value("ccd", "CCD(s) to plot [0 for all]", "0")
                if ccd == "0":
                    ccds = list(ccdinf.keys())
                else:
                    ccds = ccd.split()

                if len(ccds) > 1:
                    nxdef = min(len(ccds), nxdef)
                    cl.set_default("nx", nxdef)
                    nx = cl.get_value("nx", "number of panels in X", 3, 1)
                else:
                    nx = 1
            else:
                nx = 1
                ccds = list(ccdinf.keys())

            # define the display intensities
            msub = cl.get_value("msub", "subtract median from each window?", True)

            iset = cl.get_value(
                "iset",
                "set intensity a(utomatically)," " d(irectly) or with p(ercentiles)?",
                "a",
                lvals=["a", "d", "p"],
            )

            plo, phi = 5, 95
            ilo, ihi = 0, 1000
            if iset == "d":
                ilo = cl.get_value("ilo", "lower intensity limit", 0.0)
                ihi = cl.get_value("ihi", "upper intensity limit", 1000.0)
            elif iset == "p":
                plo = cl.get_value(
                    "plo", "lower intensity limit percentile", 5.0, 0.0, 100.0
                )
                phi = cl.get_value(
                    "phi", "upper intensity limit percentile", 95.0, 0.0, 100.0
                )

            # region to plot
            for i, cnam in enumerate(ccds):
                nxtot, nytot, nxpad, nypad = ccdinf[cnam]
                if i == 0:
                    xmin, xmax = float(-nxpad), float(nxtot + nxpad + 1)
                    ymin, ymax = float(-nypad), float(nytot + nypad + 1)
                else:
                    xmin = min(xmin, float(-nxpad))
                    xmax = max(xmax, float(nxtot + nxpad + 1))
                    ymin = min(ymin, float(-nypad))
                    ymax = max(ymax, float(nytot + nypad + 1))

            xlo = cl.get_value("xlo", "left-hand X value", xmin, xmin, xmax, enforce=False)
            xhi = cl.get_value("xhi", "right-hand X value", xmax, xmin, xmax, enforce=False)
            ylo = cl.get_value("ylo", "lower Y value", ymin, ymin, ymax, enforce=False)
            yhi = cl.get_value("yhi", "upper Y value", ymax, ymin, ymax, enforce=False)

        else:
            xlo, xhi, ylo, yhi = None, None, None, None

        # save list of parameter values for writing to the reduction file
        plist = cl.list()

    ################################################################
    #
    # all the inputs have now been obtained. Get on with doing stuff
    if implot:
        plot_lims = (xlo, xhi, ylo, yhi)
    else:
        plot_lims = None

    imdev, lcdev, spanel, tpanel, xpanel, ypanel, lpanel = setup_plots(
        rfile, ccds, nx, plot_lims, implot, lplot
    )

    # a couple of initialisations
    total_time = 0  # time waiting for new frame

    # dictionary of dictionaries for looking up the window associated with a
    # given aperture, i.e.  mccdwins[cnam][apnam] give the name of the Window.
    mccdwins = {}
    if lplot:
        lbuffer, xbuffer, ybuffer, tbuffer, sbuffer = setup_plot_buffers(rfile)
    else:
        lbuffer, xbuffer, ybuffer, tbuffer, sbuffer = None, None, None, None, None
    ############################################
    #
    # open the log file and write headers
    #
    with LogWriter(log, rfile, hipercam_version, plist) as logfile:

        ncpu = rfile["general"]["ncpu"]
        if ncpu > 1:
            pool = multiprocessing.Pool(processes=ncpu)
        else:
            pool = None

        # whether settings have been initialised
        initialised = False

        # containers for the processed and raw MCCD groups
        # and their frame numbers
        bccds, pccds, mccds, nframes = [], [], [], []

        ##############################################
        #
        # Finally, start winding through the frames
        #

        with spooler.data_source(source, resource, first, full=False) as spool:

            # 'spool' is an iterable source of MCCDs
            for nf, mccd in enumerate(spool):

                if server_or_local:

                    # Handle the waiting game ...
                    give_up, try_again, total_time = spooler.hang_about(
                        mccd, twait, tmx, total_time
                    )

                    if give_up:
                        # Giving up, but need to handle any partially filled
                        # frame group

                        if len(mccds):
                            # finish processing remaining frames. This step
                            # will only occur if we have at least once passed
                            # to later stages during which read and gain will
                            # be set up
                            results = processor(pccds, mccds, nframes)

                            # write out results to the log file
                            alerts = logfile.write_results(results)

                            # print out any accumulated alert messages
                            if len(alerts):
                                print("\n".join(alerts))

                            update_plots(
                                results,
                                rfile,
                                implot,
                                lplot,
                                imdev,
                                lcdev,
                                pccd,
                                ccds,
                                msub,
                                nx,
                                iset,
                                plo,
                                phi,
                                ilo,
                                ihi,
                                xlo,
                                xhi,
                                ylo,
                                yhi,
                                lpanel,
                                xpanel,
                                ypanel,
                                tpanel,
                                spanel,
                                tkeep,
                                lbuffer,
                                xbuffer,
                                ybuffer,
                                tbuffer,
                                sbuffer,
                            )

                        print("psf_reduce stopped")
                        break
                    elif try_again:
                        continue

                # indicate progress
                if "NFRAME" in mccd.head:
                    nframe = mccd.head["NFRAME"]
                else:
                    nframe = nf + 1

                if last and nframe > last:

                    if len(mccds):
                        # finish processing remaining frames
                        results = processor(pccds, bccds, mccds, nframes)

                        # write out results to the log file
                        alerts = logfile.write_results(results)

                        # print out any accumulated alert messages
                        if len(alerts):
                            print("\n".join(alerts))

                        update_plots(
                            results,
                            rfile,
                            implot,
                            lplot,
                            imdev,
                            lcdev,
                            pccd,
                            ccds,
                            msub,
                            nx,
                            iset,
                            plo,
                            phi,
                            ilo,
                            ihi,
                            xlo,
                            xhi,
                            ylo,
                            yhi,
                            lpanel,
                            xpanel,
                            ypanel,
                            tpanel,
                            spanel,
                            tkeep,
                            lbuffer,
                            xbuffer,
                            ybuffer,
                            tbuffer,
                            sbuffer,
                        )

                    print("\nHave reduced up to the last frame set.")
                    print("psf_reduce finished")
                    break

                print(
                    "Frame {:d}: {:s} [{:s}]".format(
                        nframe,
                        mccd.head["TIMSTAMP"],
                        "OK" if mccd.head.get("GOODTIME", True) else "NOK",
                    ),
                    end="" if implot else "\n",
                )

                if not initialised:
                    # This is the first frame  which allows us to make
                    # some checks and initialisations.
                    read, gain, ok = initial_checks(mccd, rfile)

                    # Define the CCD processor function object
                    processor = ProcessCCDs(rfile, read, gain, ccdproc, pool)

                    # set flag to show we are set
                    if not ok:
                        break
                    initialised = True

                # De-bias the data. Retain a copy of the raw data as 'mccd'
                # in order to judge saturation. Processed data called 'pccd'
                if rfile.bias is not None:
                    # subtract bias
                    pccd = mccd - rfile.bias
                    bccd = pccd.copy()
                else:
                    # no bias subtraction
                    pccd = mccd.copy()
                    bccd = pccd.copy()

                if rfile.flat is not None:
                    # apply flat field to processed frame
                    pccd /= rfile.flat

                # Acummulate frames into processing groups for faster
                # parallelisation
                pccds.append(pccd)
                bccds.append(bccd)
                mccds.append(mccd)
                nframes.append(nframe)

                if len(pccds) == rfile["general"]["ngroup"]:
                    # parallel processing. This should usually be the first
                    # points at which it takes place
                    results = processor(pccds, bccds, mccds, nframes)

                    # write out results to the log file
                    alerts = logfile.write_results(results)

                    # print out any accumulated alert messages
                    if len(alerts):
                        print("\n".join(alerts))

                    update_plots(
                        results,
                        rfile,
                        implot,
                        lplot,
                        imdev,
                        lcdev,
                        pccds[-1],
                        ccds,
                        msub,
                        nx,
                        iset,
                        plo,
                        phi,
                        ilo,
                        ihi,
                        xlo,
                        xhi,
                        ylo,
                        yhi,
                        lpanel,
                        xpanel,
                        ypanel,
                        tpanel,
                        spanel,
                        tkeep,
                        lbuffer,
                        xbuffer,
                        ybuffer,
                        tbuffer,
                        sbuffer,
                    )

                    # Reset the frame buffers
                    pccds, mccds, nframes = [], [], []


# END OF MAIN SECTION


# Stuff below here are helper routines that are not exported
class MoffatPSF(Fittable2DModel):
    """
    Standard Moffat model, but with parameter names that work with photutils

    Parameters
    ----------
    fwhm : float
        Full-Width at Half-Maximum of profile
    beta : float
        Beta parameter of Moffat profile
    flux : float (default 1)
        Total integrated flux over the entire PSF
    x_0 : float (default 0)
        Position of peak in x direction
    y_0 : float (default 0)
        Position of peak in y direction

    Notes
    -----
    This model is evaluated according to the following formula:

        .. math::
            f(x, y) = f(r) = F [1 + (r/\alpha)**2]**(-beta)

    where ``F`` is the total integrated flux, ``r`` is the distance from the central peak and ``alpha``
    is chosen so the profile has the appropriate FWHM.
    """

    flux = Parameter(default=1)
    x_0 = Parameter(default=0)
    y_0 = Parameter(default=0)
    beta = Parameter(default=2.5, fixed=True)
    fwhm = Parameter(default=12, fixed=True)

    fit_deriv = None

    @property
    def bounding_box(self):
        halfwidth = 3 * self.fwhm
        return (
            (int(self.y_0 - halfwidth), int(self.y_0 + halfwidth)),
            (int(self.x_0 - halfwidth), int(self.x_0 + halfwidth)),
        )

    def __init__(
        self,
        flux=flux.default,
        x_0=x_0.default,
        y_0=y_0.default,
        beta=beta.default,
        fwhm=fwhm.default,
        **kwargs
    ):
        super(MoffatPSF, self).__init__(
            n_models=1, flux=flux, x_0=x_0, y_0=y_0, beta=beta, fwhm=fwhm, **kwargs
        )

    def evaluate(self, x, y, flux, x_0, y_0, beta, fwhm):
        r = np.sqrt((x - x_0) ** 2 + (y - y_0) ** 2)
        alpha_sq = fwhm ** 2 / 4 / (2 ** (1 / beta) - 1)
        prof = flux / (1 + r ** 2 / alpha_sq) ** beta
        return (beta - 1) * prof / np.pi / alpha_sq


def extractFlux(cnam, ccd, rccd, read, gain, ccdwin, rfile, store):
    """This extracts the flux of all apertures of a given CCD.

    The steps are (1) creation of PSF model, (2) PSF fitting, (3)
    flux extraction. The apertures are assumed to be correctly positioned.

    It returns the results as a dictionary keyed on the aperture label. Each
    entry returns a list:

    [x, ex, y, ey, fwhm, efwhm, beta, ebeta, counts, countse, sky, esky,
    nsky, nrej, flag]

    flag = bitmask. See hipercam.core to see all the options which are
    referred to by name in the code e.g. ALL_OK. The various flags can
    signal that there no sky pixels (NO_SKY), the sky aperture was off
    the edge of the window (SKY_AT_EDGE), etc.

    This code::

       >> bset = flag & TARGET_SATURATED

    determines whether the data saturation flag is set for example.

    Arguments::

       cnam     : string
          CCD identifier label

       ccd       : CCD
           the debiassed, flat-fielded CCD.

       rccd : CCD
          corresponding raw CCD, used to work out whether data are
          saturated in target aperture.

       read      : CCD
           readnoise divided by the flat-field

       gain      : CCD
           gain multiplied by the flat field

       ccdwin   : dictionary of strings
           the Window label corresponding to each Aperture

       rfile     : Rfile
           reduce file configuration parameters

       store     : dict of dicts
           see moveApers for what this contains.

    """

    # initialise flag
    flag = hcam.ALL_OK

    ccdaper = rfile.aper[cnam]

    results = {}
    # get profile params from aperture store
    mfwhm = store["mfwhm"]
    mbeta = store["mbeta"]
    method = "m" if mbeta > 0.0 else "g"

    if mfwhm <= 0:
        # die hard, die soon as there's nothing we can do.
        print(
            (
                " *** WARNING: CCD {:s}: no measured FWHM to create PSF model"
                "; no extraction possible"
            ).format(cnam)
        )
        # set flag to indicate no FWHM
        flag = hcam.NO_FWHM

        for apnam, aper in ccdaper.items():
            info = store[apnam]
            results[apnam] = {
                "x": aper.x,
                "xe": info["xe"],
                "y": aper.y,
                "ye": info["ye"],
                "fwhm": info["fwhm"],
                "fwhme": info["fwhme"],
                "beta": info["beta"],
                "betae": info["betae"],
                "counts": NaN,
                "countse": NaN,
                "sky": NaN,
                "skye": NaN,
                "nsky": 0,
                "nrej": 0,
                "cmax": 0,
                "flag": flag,
            }
        return results

    # all apertures have to be in the same window, or we can't easily make a
    # postage stamp of the data
    wnames = set(ccdwin.values())
    if len(wnames) != 1:
        print(
            (
                " *** WARNING: CCD {:s}: not all apertures"
                " lie within the same window; no extraction possible"
            ).format(cnam)
        )

        # set flag to indicate no extraction
        flag = hcam.NO_EXTRACTION

        # return empty results
        for apnam, aper in ccdaper.items():
            info = store[apnam]
            results[apnam] = {
                "x": aper.x,
                "xe": info["xe"],
                "y": aper.y,
                "ye": info["ye"],
                "fwhm": info["fwhm"],
                "fwhme": info["fwhme"],
                "beta": info["beta"],
                "betae": info["betae"],
                "counts": NaN,
                "countse": NaN,
                "sky": NaN,
                "skye": NaN,
                "nsky": 0,
                "nrej": 0,
                "cmax": 0,
                "flag": flag,
            }
            return results
    wnam = wnames.pop()

    # PSF params are in binned pixels, so find binning
    bin_fac = ccd[wnam].xbin

    # create PSF model
    if method == "m":
        psf_model = MoffatPSF(beta=mbeta, fwhm=mfwhm / bin_fac)
    else:
        psf_model = IntegratedGaussianPRF(
            sigma=mfwhm * gaussian_fwhm_to_sigma / bin_fac
        )

    # force photometry only at aperture positions
    # this means PSF shape and positions are fixed, we are only fitting flux
    if rfile["psf_photom"]["positions"] == "fixed":
        psf_model.x_0.fixed = True
        psf_model.y_0.fixed = True

    # create instances for PSF photometry
    gfac = float(rfile["psf_photom"]["gfac"])
    sclip = float(rfile["sky"]["thresh"])
    daogroup = DAOGroup(gfac * mfwhm / bin_fac)
    mmm_bkg = MMMBackground(sigma_clip=SigmaClip(sclip))
    fitter = LevMarLSQFitter()
    fitshape_box_size = int(2 * float(rfile["psf_photom"]["fit_half_width"]) + 1)
    fitshape = (fitshape_box_size, fitshape_box_size)

    photometry_task = BasicPSFPhotometry(
        group_maker=daogroup,
        bkg_estimator=mmm_bkg,
        psf_model=psf_model,
        fitter=fitter,
        fitshape=fitshape,
    )

    # initialise flag
    flag = hcam.ALL_OK

    # extract Windows relevant for these apertures
    wdata = ccd[wnam]
    wraw = rccd[wnam]

    # extract sub-windows that include all of the apertures, plus a little
    # extra around the edges.
    x1 = min([ap.x - ap.rsky2 - wdata.xbin for ap in ccdaper.values()])
    x2 = max([ap.x + ap.rsky2 + wdata.xbin for ap in ccdaper.values()])
    y1 = min([ap.y - ap.rsky2 - wdata.ybin for ap in ccdaper.values()])
    y2 = max([ap.y + ap.rsky2 + wdata.ybin for ap in ccdaper.values()])

    # extract sub-Windows
    swdata = wdata.window(x1, x2, y1, y2)
    swraw = wraw.window(x1, x2, y1, y2)

    # compute pixel positions of apertures in windows
    xpos, ypos = zip(
        *((swdata.x_pixel(ap.x), swdata.y_pixel(ap.y)) for ap in ccdaper.values())
    )
    positions = Table(names=["x_0", "y_0"], data=(xpos, ypos))

    # do the PSF photometry
    photom_results = photometry_task(swdata.data, init_guesses=positions)
    slevel = mmm_bkg(swdata.data)

    # unpack the results and check apertures
    for apnam, aper in ccdaper.items():
        try:
            # reset flag
            flag = hcam.ALL_OK

            result_row = photom_results[photom_results["id"] == int(apnam)]
            if len(result_row) == 0:
                flag |= hcam.NO_DATA
                raise hcam.HipercamError(
                    "no source in PSF photometry for this aperture"
                )
            elif len(result_row) > 1:
                flag |= hcam.NO_EXTRACTION
                raise hcam.HipercamError(
                    "ambiguous lookup for this aperture in PSF photometry"
                )
            else:
                result_row = result_row[0]

            # compute X, Y arrays over the sub-window relative to the centre
            # of the aperture and the distance squared from the centre (Rsq)
            # to save a little effort.
            x = swdata.x(np.arange(swdata.nx)) - aper.x
            y = swdata.y(np.arange(swdata.ny)) - aper.y
            X, Y = np.meshgrid(x, y)
            Rsq = X ** 2 + Y ** 2

            # size of a pixel which is used to taper pixels as they approach
            # the edge of the aperture to reduce pixellation noise
            size = np.sqrt(wdata.xbin * wdata.ybin)

            # target selection, accounting for extra apertures and allowing
            # pixels to contribute if their centres are as far as size/2 beyond
            # the edge of the circle (but with a tapered weight)
            dok = Rsq < (aper.rtarg + size / 2.0) ** 2
            if not dok.any():
                # check there are some valid pixels
                flag |= hcam.NO_DATA
                raise hcam.HipercamError("no valid pixels in aperture")

            # check for saturation and nonlinearity
            if cnam in rfile.warn:
                if swraw.data[dok].max() >= rfile.warn[cnam]["saturation"]:
                    flag |= hcam.TARGET_SATURATED

                if swraw.data[dok].max() >= rfile.warn[cnam]["nonlinear"]:
                    flag |= hcam.TARGET_NONLINEAR
            else:
                warnings.warn("CCD {:s} has no nonlinearity or saturation levels set")

            counts = result_row["flux_fit"]
            countse = result_row["flux_unc"]
            info = store[apnam]

            results[apnam] = {
                "x": aper.x,
                "xe": info["xe"],
                "y": aper.y,
                "ye": info["ye"],
                "fwhm": info["fwhm"],
                "fwhme": info["fwhme"],
                "beta": info["beta"],
                "betae": info["betae"],
                "counts": counts,
                "countse": countse,
                "sky": slevel,
                "skye": 0,
                "nsky": 0,
                "nrej": 0,
                "cmax": 0,
                "flag": flag,
            }

        except hcam.HipercamError as err:

            info = store[apnam]
            flag |= hcam.NO_EXTRACTION

            results[apnam] = {
                "x": aper.x,
                "xe": info["xe"],
                "y": aper.y,
                "ye": info["ye"],
                "fwhm": info["fwhm"],
                "fwhme": info["fwhme"],
                "beta": info["beta"],
                "betae": info["betae"],
                "counts": NaN,
                "countse": NaN,
                "sky": NaN,
                "skye": NaN,
                "nsky": 0,
                "nrej": 0,
                "cmax": 0,
                "flag": flag,
            }

    # finally, we are done
    return results


def ccdproc(cnam, ccds, bccds, rccds, nframes, read, gain, ccdwin, rfile, store):
    """Processing steps for a sequential set of images from the same
    CCD. This is designed for parallelising the processing across CCDs
    of multiarm cameras like ULTRACAM and HiPERCAM using
    multiprocessing. To be called *after* checking that any processing
    is needed.

    Arguments::

       cnam : string
          name of CCD, for information purposes (e.g. 'red', '3', etc)

       ccds : List of CCDs
          the CCDs for processing which should have been debiassed, flat
          fielded and multiplied by the gain to get into electrons.

       rccds : List of CCDs
          unprocessed CCDs, one-to-one correspondence with 'ccds', used
          to measure saturation

       nframes : List of ints
          frame numbers for each CCD

       read : CCD
          readnoise frame divided by the flatfield

       gain : CCD
          gain frame dmultiplied by the flatfield

       ccdwin : dict
          label of the Window enclosing each aperture

       rfile : Rfile object
          reduction control parameters. rfile.aper used to store the aperture
          parameters.

       store : dict
          dictionary of results

    Returns: (cnam, list[res]) where 'res' represents a tuple
    of results for each input CCD and contains the following:

    (nframe, store, ccdaper, results, mjdint, mjdfrac, mjdok, expose)

    """
    # At this point 'ccds' contains a list of CCD each of which
    # contains all the Windows of a CCD, 'ccdaper' all of its
    # apertures, 'ccdwin' the label of the Window enclosing each
    # aperture, 'rfile' contains control parameters, 'rflat' contains
    # the readout noise in electrons and divided by the flat as a CCD,
    # 'store' is a dictionary initially with jus 'mfwhm' and 'mbeta'
    # set = -1, but will pick up extra stuff from moveApers for use by
    # extractFlux along with revised values of mfwhm and mbeta which
    # are used to initialise profile fits next time.

    res = []
    for ccd, rccd, nframe in zip(ccds, rccds, nframes):
        # Loop through the CCDs supplied

        # move the apertures.
        # NB the second 'ccd' in the argument list is a stop-gap --
        # it should actually be the debiassed-only CCD rather than
        # the fully processed version -- see reduce
        moveApers(cnam, ccd, ccd, read, gain, ccdwin, rfile, store)

        # extract flux from all apertures of each CCD. Return with the CCD
        # name, the store dictionary, ccdaper and then the results from
        # extractFlux for compatibility with multiprocessing. Note
        results = extractFlux(cnam, ccd, rccd, read, gain, ccdwin, rfile, store)

        # Save the essentials
        res.append(
            (
                nframe,
                store,
                rfile.aper[cnam],
                results,
                ccd.head["MJDINT"],
                ccd.head["MJDFRAC"],
                ccd.head.get("GOODTIME", True),
                ccd.head.get("EXPTIME", 1.0),
            )
        )

    return (cnam, res)
