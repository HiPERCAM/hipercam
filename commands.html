<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>HiPERCAM commands &#8212; HiPERCAM pipeline 1.6.7.dev17+gf476407b5 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="_static/bootstrap-astropy.css?v=177ce38d" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css?v=fd3f3429" />
    
    <script src="_static/documentation_options.js?v=c92ee6e6"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>
    <script type="text/javascript" src="_static/copybutton.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="The API" href="api/api.html" />
    <link rel="prev" title="ULTRACAM observing checklist" href="ultracam_checklist.html" />
    <link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>

  </head><body>
<div class="topbar">
  <a class="brand" title="Documentation Home" href="index.html"><span id="logotext1">astro</span><span id="logotext2"></span><span id="logotext3">:docs</span></a>
  <ul>
    
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="genindex.html">Index</a></li>
    <li><a title="Module Index" href="py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li class="right">
	<a href="api/api.html" title="The API">
	  next &raquo;
	</a>
      </li>
      <li class="right">
	<a href="ultracam_checklist.html" title="ULTRACAM observing checklist">
	  &laquo; previous
	</a>
	 |
      </li>
      <li>
	<a href="index.html">HiPERCAM pipeline 1.6.7.dev17+gf476407b5 documentation</a>
	 &#187;
      </li>
      
      <li>HiPERCAM commands</li> 
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="hiper-commands">
<h1>HiPERCAM commands<a class="headerlink" href="#hiper-commands" title="Link to this heading">¶</a></h1>
<p>This page documents the pipeline commands which are all part of
<code class="xref py py-mod docutils literal notranslate"><span class="pre">hipercam.scripts</span></code>. Help on any given command can be obtained at the
terminal using e.g. <code class="docutils literal notranslate"><span class="pre">pydoc</span> <span class="pre">hipercam.scripts</span></code> or <code class="docutils literal notranslate"><span class="pre">pydoc</span>
<span class="pre">hipercam.scripts.rtplot</span></code>. This is often the most useful way to get
information quickly. If you are new to the pipeline, it would be worth reading
the <a class="reference internal" href="#command-calling"><span class="std std-ref">Parameter specification</span></a> section on how to call the pipeline commands and
specify parameters.</p>
<nav class="contents local" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#main-commands" id="id3">Main commands</a></p></li>
<li><p><a class="reference internal" href="#parameter-specification" id="id4">Parameter specification</a></p>
<ul>
<li><p><a class="reference internal" href="#basic-parameter-input" id="id5">Basic parameter input</a></p></li>
<li><p><a class="reference internal" href="#hidden-parameters-and-special-keywords" id="id6">Hidden parameters and special keywords</a></p></li>
<li><p><a class="reference internal" href="#strings-with-spaces" id="id7">Strings with spaces</a></p></li>
<li><p><a class="reference internal" href="#setting-a-string-to-be-blank" id="id8">Setting a string to be blank</a></p></li>
<li><p><a class="reference internal" href="#parameter-ranges" id="id9">Parameter ranges</a></p></li>
<li><p><a class="reference internal" href="#tab-completion" id="id10">Tab completion</a></p></li>
<li><p><a class="reference internal" href="#global-vs-local-parameters" id="id11">Global vs local parameters</a></p></li>
<li><p><a class="reference internal" href="#trouble-shooting-parameter-input" id="id12">Trouble-shooting parameter input</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#errors-reported-by-scripts" id="id13">Errors reported by scripts</a></p></li>
<li><p><a class="reference internal" href="#command-definitions" id="id14">Command definitions</a></p></li>
</ul>
</nav>
<section id="main-commands">
<h2><a class="toc-backref" href="#id3" role="doc-backlink">Main commands</a><a class="headerlink" href="#main-commands" title="Link to this heading">¶</a></h2>
<p>This section lists the main HiPERCAM commands <a class="footnote-reference brackets" href="#f1" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> ; see also the bottom of the page
for all the documentation on the commands in one long list. Clicking on a
command name in the table below will take you to the relevant section of this long
list. The table also indicates contexts in which each command is particularly
useful.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 12.5%" />
<col style="width: 37.5%" />
<col style="width: 10.0%" />
<col style="width: 10.0%" />
<col style="width: 10.0%" />
<col style="width: 10.0%" />
<col style="width: 10.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Command</p></th>
<th class="head"><p>Purpose</p></th>
<th class="head"><p>Observing</p></th>
<th class="head"><p>Reduction</p></th>
<th class="head"><p>Plots &amp;
analysis</p></th>
<th class="head"><p>Arithematic</p></th>
<th class="head"><p>Information</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#hipercam.scripts.add" title="hipercam.scripts.add"><code class="xref py py-func docutils literal notranslate"><span class="pre">add</span></code></a></p></td>
<td><p>add two frames</p></td>
<td></td>
<td></td>
<td></td>
<td><p>Yes</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#hipercam.scripts.averun" title="hipercam.scripts.averun"><code class="xref py py-func docutils literal notranslate"><span class="pre">averun</span></code></a></p></td>
<td><p>average a series of frames in a run</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#hipercam.scripts.cadd" title="hipercam.scripts.cadd"><code class="xref py py-func docutils literal notranslate"><span class="pre">cadd</span></code></a></p></td>
<td><p>add a constant to a frame</p></td>
<td></td>
<td></td>
<td></td>
<td><p>Yes</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#hipercam.scripts.cdiv" title="hipercam.scripts.cdiv"><code class="xref py py-func docutils literal notranslate"><span class="pre">cdiv</span></code></a></p></td>
<td><p>divide a frame by a constant</p></td>
<td></td>
<td></td>
<td></td>
<td><p>Yes</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#hipercam.scripts.cmul" title="hipercam.scripts.cmul"><code class="xref py py-func docutils literal notranslate"><span class="pre">cmul</span></code></a></p></td>
<td><p>multiply a frame by a constant</p></td>
<td></td>
<td></td>
<td></td>
<td><p>Yes</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#hipercam.scripts.combine" title="hipercam.scripts.combine"><code class="xref py py-func docutils literal notranslate"><span class="pre">combine</span></code></a></p></td>
<td><p>combine a list of frames</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td></td>
<td><p>Yes</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#hipercam.scripts.csub" title="hipercam.scripts.csub"><code class="xref py py-func docutils literal notranslate"><span class="pre">csub</span></code></a></p></td>
<td><p>subtract a constant from a frame</p></td>
<td></td>
<td></td>
<td></td>
<td><p>Yes</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#hipercam.scripts.div" title="hipercam.scripts.div"><code class="xref py py-func docutils literal notranslate"><span class="pre">div</span></code></a></p></td>
<td><p>divide one frame by another</p></td>
<td></td>
<td></td>
<td></td>
<td><p>Yes</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#hipercam.scripts.exploss" title="hipercam.scripts.exploss"><code class="xref py py-func docutils literal notranslate"><span class="pre">exploss</span></code></a></p></td>
<td><p>plot reduce log readout noise loss factor</p></td>
<td><p>Yes</p></td>
<td></td>
<td></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#hipercam.scripts.fits2hcm" title="hipercam.scripts.fits2hcm"><code class="xref py py-func docutils literal notranslate"><span class="pre">fits2hcm</span></code></a></p></td>
<td><p>convert foreign FITs files to hcm format</p></td>
<td></td>
<td><p>Yes</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#hipercam.scripts.flagcloud" title="hipercam.scripts.flagcloud"><code class="xref py py-func docutils literal notranslate"><span class="pre">flagcloud</span></code></a></p></td>
<td><p>flag cloudy and junk data in a reduce log</p></td>
<td></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#hipercam.scripts.ftargets" title="hipercam.scripts.ftargets"><code class="xref py py-func docutils literal notranslate"><span class="pre">ftargets</span></code></a></p></td>
<td><p>automatically find targets using “sep”</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#hipercam.scripts.genred" title="hipercam.scripts.genred"><code class="xref py py-func docutils literal notranslate"><span class="pre">genred</span></code></a></p></td>
<td><p>create a reduce file</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#hipercam.scripts.grab" title="hipercam.scripts.grab"><code class="xref py py-func docutils literal notranslate"><span class="pre">grab</span></code></a></p></td>
<td><p>split frames out of a run</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#hipercam.scripts.hfilter" title="hipercam.scripts.hfilter"><code class="xref py py-func docutils literal notranslate"><span class="pre">hfilter</span></code></a></p></td>
<td><p>filter a HiPERCAM image</p></td>
<td></td>
<td></td>
<td></td>
<td><p>Yes</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#hipercam.scripts.hinfo" title="hipercam.scripts.hinfo"><code class="xref py py-func docutils literal notranslate"><span class="pre">hinfo</span></code></a></p></td>
<td><p>lists information on a HiPERCAM image</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#hipercam.scripts.hist" title="hipercam.scripts.hist"><code class="xref py py-func docutils literal notranslate"><span class="pre">hist</span></code></a></p></td>
<td><p>plot a histogram of a frame</p></td>
<td></td>
<td></td>
<td><p>Yes</p></td>
<td></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#hipercam.scripts.hlog2col" title="hipercam.scripts.hlog2col"><code class="xref py py-func docutils literal notranslate"><span class="pre">hlog2col</span></code></a></p></td>
<td><p>produce ASCII column data from a reduce log</p></td>
<td></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#hipercam.scripts.hlog2fits" title="hipercam.scripts.hlog2fits"><code class="xref py py-func docutils literal notranslate"><span class="pre">hlog2fits</span></code></a></p></td>
<td><p>convert a reduction log file to FITS</p></td>
<td></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#hipercam.scripts.hls" title="hipercam.scripts.hls"><code class="xref py py-func docutils literal notranslate"><span class="pre">hls</span></code></a></p></td>
<td><p>list the runs on the HiPERCAM server</p></td>
<td><p>Yes</p></td>
<td></td>
<td></td>
<td></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#hipercam.scripts.hpackage" title="hipercam.scripts.hpackage"><code class="xref py py-func docutils literal notranslate"><span class="pre">hpackage</span></code></a></p></td>
<td><p>bundles up reduce data files</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td></td>
<td></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#hipercam.scripts.hplot" title="hipercam.scripts.hplot"><code class="xref py py-func docutils literal notranslate"><span class="pre">hplot</span></code></a></p></td>
<td><p>plot a frame</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#hipercam.scripts.joinup" title="hipercam.scripts.joinup"><code class="xref py py-func docutils literal notranslate"><span class="pre">joinup</span></code></a></p></td>
<td><p>joins windows into a single image per CCD</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#hipercam.scripts.ltimes" title="hipercam.scripts.ltimes"><code class="xref py py-func docutils literal notranslate"><span class="pre">ltimes</span></code></a></p></td>
<td><p>list times of a run</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#hipercam.scripts.makebias" title="hipercam.scripts.makebias"><code class="xref py py-func docutils literal notranslate"><span class="pre">makebias</span></code></a></p></td>
<td><p>combine a run to make a bias frame</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#hipercam.scripts.makedark" title="hipercam.scripts.makedark"><code class="xref py py-func docutils literal notranslate"><span class="pre">makedark</span></code></a></p></td>
<td><p>combine a run to make a dark frame</p></td>
<td></td>
<td><p>Yes</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#hipercam.scripts.makeflat" title="hipercam.scripts.makeflat"><code class="xref py py-func docutils literal notranslate"><span class="pre">makeflat</span></code></a></p></td>
<td><p>combine a set of frames into a flat</p></td>
<td></td>
<td><p>Yes</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#hipercam.scripts.makefringe" title="hipercam.scripts.makefringe"><code class="xref py py-func docutils literal notranslate"><span class="pre">makefringe</span></code></a></p></td>
<td><p>combine a set frames into a fringe map</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#hipercam.scripts.makemovie" title="hipercam.scripts.makemovie"><code class="xref py py-func docutils literal notranslate"><span class="pre">makemovie</span></code></a></p></td>
<td><p>makes stills for movies from a run</p></td>
<td></td>
<td></td>
<td><p>Yes</p></td>
<td></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#hipercam.scripts.mstats" title="hipercam.scripts.mstats"><code class="xref py py-func docutils literal notranslate"><span class="pre">mstats</span></code></a></p></td>
<td><p>list stats of multiple frames from a run</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#hipercam.scripts.mul" title="hipercam.scripts.mul"><code class="xref py py-func docutils literal notranslate"><span class="pre">mul</span></code></a></p></td>
<td><p>multiply two frames</p></td>
<td></td>
<td></td>
<td></td>
<td><p>Yes</p></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#hipercam.scripts.ncal" title="hipercam.scripts.ncal"><code class="xref py py-func docutils literal notranslate"><span class="pre">ncal</span></code></a></p></td>
<td><p>noise calibration</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#hipercam.scripts.nrtplot" title="hipercam.scripts.nrtplot"><code class="xref py py-func docutils literal notranslate"><span class="pre">nrtplot</span></code></a></p></td>
<td><p>plot frames as they come in [matplotlib]</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#hipercam.scripts.pbands" title="hipercam.scripts.pbands"><code class="xref py py-func docutils literal notranslate"><span class="pre">pbands</span></code></a></p></td>
<td><p>plot <a class="reference internal" href="#hipercam.scripts.reduce" title="hipercam.scripts.reduce"><code class="xref py py-func docutils literal notranslate"><span class="pre">reduce</span></code></a> log as a lightcurve per CCD</p></td>
<td><p>Yes</p></td>
<td></td>
<td><p>Yes</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#hipercam.scripts.plog" title="hipercam.scripts.plog"><code class="xref py py-func docutils literal notranslate"><span class="pre">plog</span></code></a></p></td>
<td><p>flexible plot of a <a class="reference internal" href="#hipercam.scripts.reduce" title="hipercam.scripts.reduce"><code class="xref py py-func docutils literal notranslate"><span class="pre">reduce</span></code></a> log</p></td>
<td><p>Yes</p></td>
<td></td>
<td><p>Yes</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#hipercam.scripts.redanal" title="hipercam.scripts.redanal"><code class="xref py py-func docutils literal notranslate"><span class="pre">redanal</span></code></a></p></td>
<td><p>analyse a reduction log file</p></td>
<td></td>
<td><p>Yes</p></td>
<td></td>
<td></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#hipercam.scripts.reduce" title="hipercam.scripts.reduce"><code class="xref py py-func docutils literal notranslate"><span class="pre">reduce</span></code></a></p></td>
<td><p>carry out photometric reduction</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#hipercam.scripts.rtplot" title="hipercam.scripts.rtplot"><code class="xref py py-func docutils literal notranslate"><span class="pre">rtplot</span></code></a></p></td>
<td><p>plot frames as they come in [pgplot]</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#hipercam.scripts.rupdate" title="hipercam.scripts.rupdate"><code class="xref py py-func docutils literal notranslate"><span class="pre">rupdate</span></code></a></p></td>
<td><p>updates old reduce files</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#hipercam.scripts.setaper" title="hipercam.scripts.setaper"><code class="xref py py-func docutils literal notranslate"><span class="pre">setaper</span></code></a></p></td>
<td><p>define the photometric apertures</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#hipercam.scripts.setdefect" title="hipercam.scripts.setdefect"><code class="xref py py-func docutils literal notranslate"><span class="pre">setdefect</span></code></a></p></td>
<td><p>define a file of CCD defects</p></td>
<td><p>Yes</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#hipercam.scripts.setfringe" title="hipercam.scripts.setfringe"><code class="xref py py-func docutils literal notranslate"><span class="pre">setfringe</span></code></a></p></td>
<td><p>define peak/trough pairs for fringe measurement</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#hipercam.scripts.shiftadd" title="hipercam.scripts.shiftadd"><code class="xref py py-func docutils literal notranslate"><span class="pre">shiftadd</span></code></a></p></td>
<td><p>combine frames after aligning based on reduced positions</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#hipercam.scripts.splice" title="hipercam.scripts.splice"><code class="xref py py-func docutils literal notranslate"><span class="pre">splice</span></code></a></p></td>
<td><p>splice two frames together</p></td>
<td></td>
<td></td>
<td></td>
<td><p>Yes</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#hipercam.scripts.stats" title="hipercam.scripts.stats"><code class="xref py py-func docutils literal notranslate"><span class="pre">stats</span></code></a></p></td>
<td><p>report statistics of a frame</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><p>Yes</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#hipercam.scripts.sub" title="hipercam.scripts.sub"><code class="xref py py-func docutils literal notranslate"><span class="pre">sub</span></code></a></p></td>
<td><p>subtract two frames</p></td>
<td></td>
<td></td>
<td></td>
<td><p>Yes</p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#hipercam.scripts.uls" title="hipercam.scripts.uls"><code class="xref py py-func docutils literal notranslate"><span class="pre">uls</span></code></a></p></td>
<td><p>list the runs on the ULTRACAM server</p></td>
<td><p>Yes</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="parameter-specification">
<span id="command-calling"></span><h2><a class="toc-backref" href="#id4" role="doc-backlink">Parameter specification</a><a class="headerlink" href="#parameter-specification" title="Link to this heading">¶</a></h2>
<p>The pipeline commands are distinct from standard unix commands in having a
‘memory’, which is implemented through storage of inputs in disk files for
each command, and also in prompting you if you don’t specify a parameter on
the command line. Parameters can be ‘global’ or ‘local’ depending upon whether
they are reset across multiple commands or just the command of interest. The
parameter memory, along with the use of backslashes ‘\\’ to accept default
values can save a huge amount of typing making for efficient operation once
you get up to speed.</p>
<section id="basic-parameter-input">
<h3><a class="toc-backref" href="#id5" role="doc-backlink">Basic parameter input</a><a class="headerlink" href="#basic-parameter-input" title="Link to this heading">¶</a></h3>
<p>The command <a class="reference internal" href="#hipercam.scripts.rtplot" title="hipercam.scripts.rtplot"><code class="xref py py-func docutils literal notranslate"><span class="pre">rtplot</span></code></a> has more parameters than most others and is a
good one to start with (see also its replacement <a class="reference internal" href="#hipercam.scripts.nrtplot" title="hipercam.scripts.nrtplot"><code class="xref py py-func docutils literal notranslate"><span class="pre">nrtplot</span></code></a>). Suppose
then that we have a raw HiPERCAM file, <code class="file docutils literal notranslate"><span class="pre">run0076.fits</span></code>, that we
want to plot. If we type ‘rtplot’ and follow the prompts, the first
few lines might be:</p>
<div class="highlight-rest notranslate"><div class="highlight"><pre><span></span>rtplot
run - run name [run0064]: run0076
first - first frame to plot [10]: 1
</pre></div>
</div>
<p>This shows that the last time <a class="reference internal" href="#hipercam.scripts.rtplot" title="hipercam.scripts.rtplot"><code class="xref py py-func docutils literal notranslate"><span class="pre">rtplot</span></code></a> was invoked, it was used to look
as <code class="file docutils literal notranslate"><span class="pre">run0064.fits</span></code> starting with frame 10. Note that the extension
‘.fits’ is not needed: HiPERCAM makes significant use of extensions to
differentiate between different forms of file, all of which could be
associated with the same run and therefore start with the ‘run0064’ or whatever.
Alternatively we could have typed:</p>
<div class="highlight-rest notranslate"><div class="highlight"><pre><span></span>rtplot run0076
first - first frame to plot [10]: 1
</pre></div>
</div>
<p>which would accomplish the same, setting the run name according to its
position in the command-line arguments. For this to work, you need to be
certain of the ordering. If you are not sure of the order, but you are sure
that the parameter is called <code class="docutils literal notranslate"><span class="pre">run</span></code>, then:</p>
<div class="highlight-rest notranslate"><div class="highlight"><pre><span></span>rtplot run=run0076
first - first frame to plot [10]: 1
</pre></div>
</div>
<p>will do, and the first two parameters could be similarly specified:</p>
<div class="highlight-rest notranslate"><div class="highlight"><pre><span></span>rtplot first=1 run=run0076
</pre></div>
</div>
<p>Note that by naming the parameters, the order becomes immaterial. Now,
assuming that the command was completed, if you run <a class="reference internal" href="#hipercam.scripts.rtplot" title="hipercam.scripts.rtplot"><code class="xref py py-func docutils literal notranslate"><span class="pre">rtplot</span></code></a> again you
might get:</p>
<div class="highlight-rest notranslate"><div class="highlight"><pre><span></span>rtplot
run - run name [run0076]:
first - first frame to plot [1]:
ccd - CCD(s) to plot [0 for all] [3]: 3 4
nx - number of panels in X [2]:
bias - bias frame [&#39;none&#39; to ignore] [none]:
msub - subtract median from each window? [False]: True
</pre></div>
</div>
<p>You will see that the defaults for <code class="docutils literal notranslate"><span class="pre">run</span></code> and <code class="docutils literal notranslate"><span class="pre">first</span></code> have been updated by
the previous invocations of the command. This the parameter “memory” referred
to earlier.  Now suppose that we wish to repeat the command without changing
any parameter.  Then a simple:</p>
<div class="highlight-rest notranslate"><div class="highlight"><pre><span></span>rtplot \\
</pre></div>
</div>
<p>will do. The double backslash ‘\\\\’ indicates “take the default value for
all remaining parameters”. Two are needed because the shell will strip one of
them. If you let at least one prompting line be output then a single backslash
will accomplish the same thing:</p>
<div class="highlight-rest notranslate"><div class="highlight"><pre><span></span>rtplot
run - run name [run0076]: \
</pre></div>
</div>
<p>If you wish to change just one parameter, say <code class="docutils literal notranslate"><span class="pre">msub</span></code>, then much typing can
be saved with:</p>
<div class="highlight-rest notranslate"><div class="highlight"><pre><span></span>rtplot msub=no \\
</pre></div>
</div>
<p>(NB: Boolean True/False parameters like <code class="docutils literal notranslate"><span class="pre">msub</span></code> can be reset False with either
‘no’, ‘false’ or even just ‘n’.) Combined with up and down arrow keys, and
commands can be quickly repeated or modified.</p>
</section>
<section id="hidden-parameters-and-special-keywords">
<h3><a class="toc-backref" href="#id6" role="doc-backlink">Hidden parameters and special keywords</a><a class="headerlink" href="#hidden-parameters-and-special-keywords" title="Link to this heading">¶</a></h3>
<p>A look through the <a class="reference internal" href="#command-definitions"><span class="std std-ref">Command definitions</span></a> will reveal that many commands
have “hidden” parameters that are not usually prompted for. The idea behind
this is to reduce the level of prompting, particularly for those parameters
that hardly ever change. The values of all parameters can be revealed through
the use of a special keyword <code class="docutils literal notranslate"><span class="pre">list`</span></code>:</p>
<div class="highlight-rest notranslate"><div class="highlight"><pre><span></span>rtplot list \\
rtplot
source = hl
device = 1/xs
width = 0.0
height = 0.0
run = run0076
first = 1
twait = 10.0
tmax = 20.0
ccd = 3 4
nx = 2
pause = 0.0
plotall = False
bias = none
msub = True
iset = p
plo = 10.0
phi = 99.7
xlo = 600.0
xhi = 950.0
ylo = 100.0
yhi = 400.0
</pre></div>
</div>
<p>This reveals parameters <code class="docutils literal notranslate"><span class="pre">source</span></code>, <code class="docutils literal notranslate"><span class="pre">device</span></code>, <code class="docutils literal notranslate"><span class="pre">width</span></code> and <code class="docutils literal notranslate"><span class="pre">height</span></code> that
were never prompted for in the commands of the previous section. Their values
can be changed by giving another special keyword <code class="docutils literal notranslate"><span class="pre">prompt</span></code>:</p>
<blockquote>
<div><p>rtplot prompt
source - data source [hs, hl, us, ul, hf] [hl]:
device - plot device [1/xs]:
width - plot width (inches) [0.0]: 10
height - plot height (inches) [0.0]: 8
run - run name [run0076]:</p>
</div></blockquote>
<p>etc. Usually once changed in this way, the hidden parameters will keep the
new values, although there are some which will return to a standard default
on the basis that it is almost always what is wanted and it would be dangerous
to default to a different value.</p>
<p>In addition to <code class="docutils literal notranslate"><span class="pre">list</span></code> and <code class="docutils literal notranslate"><span class="pre">prompt</span></code>, there is a third special keyword
<code class="docutils literal notranslate"><span class="pre">nodefs</span></code> which means do not read or write any default parameter values from
files. If <code class="docutils literal notranslate"><span class="pre">nodefs</span></code> is specified, then all parameters values need to be spelt
out; it’s use is inside scripts in circumstances where multiple instances are
being used, or when there is interactive work going on too, to avoid causing
problems by over-writing the default files. Avoid using these keywords in any other
context. e.g. you would be asking for trouble if you named your files <code class="docutils literal notranslate"><span class="pre">list.hcm</span></code>
or <code class="docutils literal notranslate"><span class="pre">prompt.hcm</span></code>.</p>
</section>
<section id="strings-with-spaces">
<h3><a class="toc-backref" href="#id7" role="doc-backlink">Strings with spaces</a><a class="headerlink" href="#strings-with-spaces" title="Link to this heading">¶</a></h3>
<p>If you need to specify a string with a space in it, either let a command
prompt you and type as normal, or quote it on the command line, e.g.:</p>
<div class="highlight-rest notranslate"><div class="highlight"><pre><span></span>rtplot run=&quot;silly file name&quot; \\
</pre></div>
</div>
</section>
<section id="setting-a-string-to-be-blank">
<h3><a class="toc-backref" href="#id8" role="doc-backlink">Setting a string to be blank</a><a class="headerlink" href="#setting-a-string-to-be-blank" title="Link to this heading">¶</a></h3>
<p>If you want to set a string to a blank, then a carriage return won’t work
when prompted for it since this will just keep whatever default is
set. Instead type ‘’ (two single quotes) which will be interpreted as
implying an empty string.</p>
</section>
<section id="parameter-ranges">
<h3><a class="toc-backref" href="#id9" role="doc-backlink">Parameter ranges</a><a class="headerlink" href="#parameter-ranges" title="Link to this heading">¶</a></h3>
<p>Many numerical parameters have mimimum and/or maximum values set. Typing
‘?’ at the prompt should tell you what the values are. Typing ‘min’ or ‘max’
will set the parameter to have the appropriate value.</p>
</section>
<section id="tab-completion">
<h3><a class="toc-backref" href="#id10" role="doc-backlink">Tab completion</a><a class="headerlink" href="#tab-completion" title="Link to this heading">¶</a></h3>
<p>File name input is helped by tab completion: start typing, hit &lt;tab&gt;
and if the file exists, the name might be completed.</p>
</section>
<section id="global-vs-local-parameters">
<h3><a class="toc-backref" href="#id11" role="doc-backlink">Global vs local parameters</a><a class="headerlink" href="#global-vs-local-parameters" title="Link to this heading">¶</a></h3>
<p>All HiPERCAM pipeline parameters fall into one of two classes, either being
‘local’ to a command or ‘global’ to multiple commands. The <code class="docutils literal notranslate"><span class="pre">run</span></code> parameter
of <a class="reference internal" href="#hipercam.scripts.rtplot" title="hipercam.scripts.rtplot"><code class="xref py py-func docutils literal notranslate"><span class="pre">rtplot</span></code></a> for instance also appears in <a class="reference internal" href="#hipercam.scripts.grab" title="hipercam.scripts.grab"><code class="xref py py-func docutils literal notranslate"><span class="pre">grab</span></code></a> and if you change it in
<a class="reference internal" href="#hipercam.scripts.rtplot" title="hipercam.scripts.rtplot"><code class="xref py py-func docutils literal notranslate"><span class="pre">rtplot</span></code></a>, it will be changed in <a class="reference internal" href="#hipercam.scripts.grab" title="hipercam.scripts.grab"><code class="xref py py-func docutils literal notranslate"><span class="pre">grab</span></code></a>. This is very useful when running
a series of commands on the same file as the commands almost ‘know’ what you want,
saving much typing.</p>
</section>
<section id="trouble-shooting-parameter-input">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">Trouble-shooting parameter input</a><a class="headerlink" href="#trouble-shooting-parameter-input" title="Link to this heading">¶</a></h3>
<p>It very rarely happens that the file I/O needed to read the default values
can get confused. This can happen e.g. if the data type of a parameter has
changed. If very odd things seems to happen when you try to start a command,
then you might want to track down where the default files are located. Usually
this will be in <cite>.hipercam</cite> in your home directory, unless the environment
variable <cite>HIPERCAM_ENV</cite> has been defined to re-direct where the default files
are stored. Once you have located them it is always safe to delete one or more
or all of the default files (end with .def). The worst that happens is that
the commands have lost the default values.</p>
</section>
</section>
<section id="errors-reported-by-scripts">
<h2><a class="toc-backref" href="#id13" role="doc-backlink">Errors reported by scripts</a><a class="headerlink" href="#errors-reported-by-scripts" title="Link to this heading">¶</a></h2>
<p>If you use the pipeline for any significant time, you will at some point
get a rather forbidding-looking error traceback such as:</p>
<div class="highlight-rest notranslate"><div class="highlight"><pre><span></span>reduce run=run013 \\
Traceback (most recent call last):
  File &quot;/storage/astro1/phsaap/software/python/bin/reduce&quot;, line 11, in &lt;module&gt;
    load_entry_point(&#39;hipercam==0.19.9.dev22+g758df9d.d20200303&#39;, &#39;console_scripts&#39;, &#39;reduce&#39;)()
  File &quot;/storage/astro1/phsaap/software/python/lib/python3.6/site-packages/hipercam/scripts/reduce.py&quot;, line 405, in reduce
    with spooler.data_source(source, resource, first, full=False) as spool:
  File &quot;/storage/astro1/phsaap/software/python/lib/python3.6/site-packages/hipercam/spooler.py&quot;, line 323, in data_source
    return UcamDiskSpool(resource, first)
  File &quot;/storage/astro1/phsaap/software/python/lib/python3.6/site-packages/hipercam/spooler.py&quot;, line 108, in __init__
    self._iter = ucam.Rdata(run, first, False)
  File &quot;/storage/astro1/phsaap/software/python/lib/python3.6/site-packages/hipercam/ucam.py&quot;, line 637, in __init__
    Rhead.__init__(self, run, server)
  File &quot;/storage/astro1/phsaap/software/python/lib/python3.6/site-packages/hipercam/ucam.py&quot;, line 152, in __init__
    udom = xml.dom.minidom.parse(run + &#39;.xml&#39;)
  File &quot;/warwick/desktop/2018/software/MPI/GCC/7.3.0-2.30/OpenMPI/3.1.1/Python/3.6.6/lib/python3.6/xml/dom/minidom.py&quot;, line 1958, in parse
    return expatbuilder.parse(file)
  File &quot;/warwick/desktop/2018/software/MPI/GCC/7.3.0-2.30/OpenMPI/3.1.1/Python/3.6.6/lib/python3.6/xml/dom/expatbuilder.py&quot;, line 910, in parse
    with open(file, &#39;rb&#39;) as fp:
FileNotFoundError: [Errno 2] No such file or directory: &#39;run013.xml&#39;
</pre></div>
</div>
<p>Yikes! Although it looks awful, it simply reflects
the chain of function calls that led to the problem, an extremely
useful diagnostic of problems in Python code. Such tracebacks look a
bit ugly, but almost certainly, in most cases, including this one,
they are caused by incorrect parameter inputs. The one to look at is
probably the last line or two, which reveals in this case that an expected
file ‘run013.xml’ was not found; a directory listing would confirm this.</p>
<p>Such errors follow from a standard Python approach of not trying to
add endless checking code, but to let the code tell you what happened
when errors are encountered. This has the merit of being very
informative (and de-clutters code), but it can make it hard to
distinguish between an essentially trivial issue, such as a missing
file, and a genuine problem with the code. If however you find you
can’t get round a problem and the error reported does not look
innocent, then it might be a time to <a class="reference internal" href="api/bugs.html#reporting-problems"><span class="std std-ref">report the
problem</span></a>. We will do our best to provide fast
solutions to critical issues.</p>
</section>
<section id="command-definitions">
<span id="id2"></span><h2><a class="toc-backref" href="#id14" role="doc-backlink">Command definitions</a><a class="headerlink" href="#command-definitions" title="Link to this heading">¶</a></h2>
<p>This section contains documentation auto-generated from the code. This
is the same as is returned from clicking command names in the lists at
the top of this page or from using <code class="docutils literal notranslate"><span class="pre">pydoc</span></code> in a terminal (e.g. try
<code class="docutils literal notranslate"><span class="pre">pydoc</span> <span class="pre">hipercam.scripts.reduce</span></code>). Each command appears as a function
(an implementation detail), followed by a highlighted line showing the
parameters one can use on the command-line. Inputs in square brackets
such as <code class="docutils literal notranslate"><span class="pre">[source]</span></code> are hidden by default; those in round brackets
e.g. <code class="docutils literal notranslate"><span class="pre">(plot)</span></code> may or may not be prompted depending upon earlier
inputs. It is always safest when first running a command simply to
type its name and hit enter and let the command itself prompt you for
input. Many commands have hidden parameters that can only be revealed
by typing e.g. <code class="docutils literal notranslate"><span class="pre">rtplot</span> <span class="pre">prompt</span></code>. These are usually parameters that
rarely need changing, but you are sure sometimes to need to alter
them.  See the <a class="reference internal" href="#command-calling"><span class="std std-ref">Parameter specification</span></a> section for details on how to
specify command parameters.</p>
<p>In the one-line descriptions below, <code class="docutils literal notranslate"><span class="pre">run</span></code> refers to a complete run,
containing multiple images, stored in a .fits file. <code class="docutils literal notranslate"><span class="pre">frame</span></code> refers to a
single image from a run as might be extracted using <a class="reference internal" href="#hipercam.scripts.grab" title="hipercam.scripts.grab"><code class="xref py py-func docutils literal notranslate"><span class="pre">grab</span></code></a>. These have file
extension ‘.hcm’ to distinguish them, although they are also FITS-format files.</p>
<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.add">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.add" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">add</span> <span class="pre">input1</span> <span class="pre">input2</span> <span class="pre">[ccd</span> <span class="pre">win]</span> <span class="pre">output</span></code></p>
<p>Adds two hcm frames and outputs the result. Can be applied only to
particular CCDs and windows if wanted.</p>
<p>Parameters:</p>
<blockquote>
<div><dl class="simple">
<dt>input1<span class="classifier">string</span></dt><dd><p>first input hcm file</p>
</dd>
<dt>input2<span class="classifier">string</span></dt><dd><p>second input hcm file to add to the first.</p>
</dd>
<dt>ccd<span class="classifier">string [hidden, defaults to ‘all’]</span></dt><dd><p>the CCD or CCDs to apply the operation to. ‘all’ for the whole lot
which it returns to by default.  Can be several e.g. ‘2 4’ or just
one ‘3’</p>
</dd>
<dt>win<span class="classifier">string [hidden, defaults to ‘all’]</span></dt><dd><p>the CCD or CCDs to apply the operation to. ‘all’ for the whole lot
which it returns to by default.  Can be several e.g. ‘E2 G1’ or just
one ‘H1’. If you specify windows in this manner, it is assumed that
all the CCDs chosen in the previous input have the named windows;
‘all’ just applies the operation to all windows regardless.</p>
</dd>
<dt>output<span class="classifier">string</span></dt><dd><p>output hcm file name. Can be same as either input1 or input2
in which case the input file will be over-written.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.averun">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">averun</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.averun" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">averun</span> <span class="pre">[source]</span> <span class="pre">(run</span> <span class="pre">first</span> <span class="pre">last</span> <span class="pre">twait</span> <span class="pre">tmax</span> <span class="pre">|</span> <span class="pre">flist)</span> <span class="pre">trim</span> <span class="pre">([ncol</span>
<span class="pre">nrow])</span> <span class="pre">bias</span> <span class="pre">dark</span> <span class="pre">flat</span> <span class="pre">fmap</span> <span class="pre">(fpair</span> <span class="pre">[nhalf</span> <span class="pre">rmin</span> <span class="pre">rmax])</span> <span class="pre">[method</span> <span class="pre">sigma</span>
<span class="pre">adjust</span> <span class="pre">clobber]</span> <span class="pre">output</span></code></p>
<p>Averages images from a run using median combination, skipping the junk
frames that result from NSKIP / NBLUE options in HiPERCAM and ULTRACAM
data. <cite>averun</cite> is meant to be a simple tool to create median frames
suitable prior to aperture selection with <cite>setaper</cite>. See <cite>combine</cite> if you
want more fine-grained control over frame averaging. (<cite>averun</cite> uses a
combination of <cite>grab</cite> [if needed] and <cite>combine</cite>).</p>
<p>Parameters:</p>
<blockquote>
<div><dl>
<dt>source<span class="classifier">str [hidden]</span></dt><dd><p>Data source, five options:</p>
<blockquote>
<div><div class="line-block">
<div class="line">‘hs’ : HiPERCAM server</div>
<div class="line">‘hl’ : local HiPERCAM FITS file</div>
<div class="line">‘us’ : ULTRACAM server</div>
<div class="line">‘ul’ : local ULTRACAM .xml/.dat files</div>
<div class="line">‘hf’ : list of HiPERCAM hcm FITS-format files</div>
</div>
</div></blockquote>
<p>‘hf’ is used to look at sets of frames generated by ‘grab’
or converted from foreign data formats. The standard
start-off default for <code class="docutils literal notranslate"><span class="pre">source</span></code> can be set using the
environment variable HIPERCAM_DEFAULT_SOURCE. e.g. in bash
<code class="code docutils literal notranslate"><span class="pre">export</span> <span class="pre">HIPERCAM_DEFAULT_SOURCE=&quot;us&quot;</span></code> would ensure it
always started with the ULTRACAM server by default. If
unspecified, it defaults to ‘hl’.</p>
</dd>
<dt>run<span class="classifier">str [if source ends ‘s’ or ‘l’]</span></dt><dd><p>run number to access, e.g. ‘run034’</p>
</dd>
<dt>flist<span class="classifier">str [if source ends ‘f’]</span></dt><dd><p>name of file list</p>
</dd>
<dt>first<span class="classifier">int [if source ends ‘s’ or ‘l’]</span></dt><dd><p>exposure number to start from. 1 = first frame (‘0’ is
not supported).</p>
</dd>
<dt>last<span class="classifier">int [if source ends ‘s’ or ‘l’]</span></dt><dd><p>last exposure number must be &gt;= first, or 0 for the lot</p>
</dd>
<dt>twait<span class="classifier">float [if source ends ‘s’ or ‘l’; hidden]</span></dt><dd><p>time to wait between attempts to find a new exposure, seconds.</p>
</dd>
<dt>tmax<span class="classifier">float [if source ends ‘s’ or ‘l’; hidden]</span></dt><dd><p>maximum time to wait between attempts to find a new exposure,
seconds.</p>
</dd>
<dt>trim<span class="classifier">bool</span></dt><dd><p>True to trim columns and/or rows off the edges of windows nearest
the readout. Useful for ULTRACAM particularly.</p>
</dd>
<dt>ncol<span class="classifier">int [if trim, hidden]</span></dt><dd><p>Number of columns to remove (on left of left-hand window, and right
of right-hand windows)</p>
</dd>
<dt>nrow<span class="classifier">int [if trim, hidden]</span></dt><dd><p>Number of rows to remove (bottom of windows)</p>
</dd>
<dt>bias<span class="classifier">str</span></dt><dd><p>Name of bias frame to subtract, ‘none’ to ignore.</p>
</dd>
<dt>dark<span class="classifier">str</span></dt><dd><p>Name of dark frame to subtract, ‘none’ to ignore.</p>
</dd>
<dt>flat<span class="classifier">str</span></dt><dd><p>Name of flat field to divide by, ‘none’ to ignore.</p>
</dd>
<dt>fmap<span class="classifier">str</span></dt><dd><p>Name of fringe map (see e.g. <cite>makefringe</cite>), ‘none’ to ignore.</p>
</dd>
<dt>fpair<span class="classifier">str [if fmap is not ‘none’]</span></dt><dd><p>Name of fringe pair file (see e.g. <cite>setfringe</cite>). Required if
a fringe map has been specified.</p>
</dd>
<dt>nhalf<span class="classifier">int [if fmap is not ‘none’, hidden]</span></dt><dd><p>When calculating the differences for fringe measurement,
a region extending +/-nhalf binned pixels will be used when
measuring the amplitudes. Basically helps the stats.</p>
</dd>
<dt>rmin<span class="classifier">float [if fmap is not ‘none’, hidden]</span></dt><dd><p>Minimum individual ratio to accept prior to calculating the overall
median in order to reduce the effect of outliers. Although all ratios
should be positive, you might want to set this a little below zero
to allow for some statistical fluctuation.</p>
</dd>
<dt>rmax<span class="classifier">float [if fmap is not ‘none’, hidden]</span></dt><dd><p>Maximum individual ratio to accept prior to calculating the overall
median in order to reduce the effect of outliers. Probably typically
&lt; 1 if fringe map was created from longer exposure data.</p>
</dd>
<dt>method<span class="classifier">str [hidden, defaults to ‘m’]</span></dt><dd><p>‘m’ for median, ‘c’ for clipped mean. See below for pros and cons.</p>
</dd>
<dt>sigma<span class="classifier">float [hidden; if method == ‘c’]</span></dt><dd><p>With clipped mean combination, pixels that deviate by more than
sigma RMS from the mean are kicked out. This is carried out in an
iterative manner. sigma &lt;= 0 implies no rejection, just a straight
average. sigma=3 is typical.</p>
</dd>
<dt>adjust<span class="classifier">str [hidden; defaults to ‘i’]</span></dt><dd><p>adjustments to make: ‘i’ = ignore; ‘n’ = normalise the mean of all
frames to match the first; ‘b’ = add offsets so that the mean of
all frames is the same as the first.  Option ‘n’ is useful for
twilight flats; ‘b’ for combining biases.</p>
</dd>
<dt>clobber<span class="classifier">bool [hidden]</span></dt><dd><p>clobber any pre-existing output files</p>
</dd>
<dt>output<span class="classifier">str</span></dt><dd><p>output file. Set by default to match the last part of “run”
(but it will have a different extension so they won’t
clash)</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.cadd">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">cadd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.cadd" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">cadd</span> <span class="pre">input</span> <span class="pre">const</span> <span class="pre">[ccd</span> <span class="pre">win]</span> <span class="pre">output</span></code></p>
<p>Adds a constant to a HiPERCAM hcm frame. Can be applied only to particular
CCDs and windows if wanted.</p>
<p>Parameters:</p>
<blockquote>
<div><dl class="simple">
<dt>input<span class="classifier">string</span></dt><dd><p>input hcm file name</p>
</dd>
<dt>const<span class="classifier">float</span></dt><dd><p>constant to add</p>
</dd>
<dt>ccd<span class="classifier">string [hidden, defaults to ‘all’]</span></dt><dd><p>the CCD or CCDs to apply the operation to. ‘all’ for the whole lot
which it returns to by default.  Can be several e.g. ‘2 4’ or just
one ‘3’</p>
</dd>
<dt>win<span class="classifier">string [hidden, defaults to ‘all’]</span></dt><dd><p>the CCD or CCDs to apply the operation to. ‘all’ for the whole lot
which it returns to by default.  Can be several e.g. ‘E2 G1’ or just
one ‘H1’. If you specify windows in this manner, it is assumed that
all the CCDs chosen in the previous input have the named windows;
‘all’ just applies the operation to all windows regardless.</p>
</dd>
<dt>output<span class="classifier">string</span></dt><dd><p>output hcm file name. Can be same as input in which case
the file will be over-written.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.cdiv">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">cdiv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.cdiv" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">cdiv</span> <span class="pre">input</span> <span class="pre">const</span> <span class="pre">[ccd</span> <span class="pre">win]</span> <span class="pre">output</span></code></p>
<p>Divides a HiPERCAM hcm frame by a constant. Can be applied only to
particular CCDs and windows if wanted.</p>
<p>Parameters:</p>
<blockquote>
<div><dl class="simple">
<dt>input<span class="classifier">string</span></dt><dd><p>input hcm file name</p>
</dd>
<dt>const<span class="classifier">float</span></dt><dd><p>constant to divide by</p>
</dd>
<dt>ccd<span class="classifier">string [hidden, defaults to ‘all’]</span></dt><dd><p>the CCD or CCDs to apply the operation to. ‘all’ for the whole lot
which it returns to by default.  Can be several e.g. ‘2 4’ or just
one ‘3’</p>
</dd>
<dt>win<span class="classifier">string [hidden, defaults to ‘all’]</span></dt><dd><p>the CCD or CCDs to apply the operation to. ‘all’ for the whole lot
which it returns to by default.  Can be several e.g. ‘E2 G1’ or just
one ‘H1’. If you specify windows in this manner, it is assumed that
all the CCDs chosen in the previous input have the named windows;
‘all’ just applies the operation to all windows regardless.</p>
</dd>
<dt>output<span class="classifier">string</span></dt><dd><p>output hcm file name. Can be same as input in which case
the file will be over-written.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.cmul">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">cmul</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.cmul" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">cmul</span> <span class="pre">input</span> <span class="pre">const</span> <span class="pre">[ccd</span> <span class="pre">win]</span> <span class="pre">output</span></code></p>
<p>Multiplies a HiPERCAM hcm frame by a constant. Can be applied only to
particular CCDs and windows if wanted.</p>
<p>Parameters:</p>
<blockquote>
<div><dl class="simple">
<dt>input<span class="classifier">string</span></dt><dd><p>input hcm file name</p>
</dd>
<dt>const<span class="classifier">float</span></dt><dd><p>constant to multiply by</p>
</dd>
<dt>ccd<span class="classifier">string [hidden, defaults to ‘all’]</span></dt><dd><p>the CCD or CCDs to apply the operation to. ‘all’ for the whole lot
which it returns to by default.  Can be several e.g. ‘2 4’ or just
one ‘3’</p>
</dd>
<dt>win<span class="classifier">string [hidden, defaults to ‘all’]</span></dt><dd><p>the CCD or CCDs to apply the operation to. ‘all’ for the whole lot
which it returns to by default.  Can be several e.g. ‘E2 G1’ or just
one ‘H1’. If you specify windows in this manner, it is assumed that
all the CCDs chosen in the previous input have the named windows;
‘all’ just applies the operation to all windows regardless.</p>
</dd>
<dt>output<span class="classifier">string</span></dt><dd><p>output hcm file name. Can be same as input in which case
the file will be over-written.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.combine">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">combine</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.combine" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">combine</span> <span class="pre">list</span> <span class="pre">bias</span> <span class="pre">dark</span> <span class="pre">flat</span> <span class="pre">method</span> <span class="pre">(sigma)</span> <span class="pre">adjust</span> <span class="pre">(usemean)</span> <span class="pre">[plot</span> <span class="pre">clobber]</span>
<span class="pre">output</span></code></p>
<p>Combines a series of images defined by a list using median or clipped
mean combination. Only combines those CCDs for which is_data() is true
(i.e. it skips blank frames caused by NSKIP / NBLUE options)</p>
<p>Parameters:</p>
<blockquote>
<div><blockquote>
<div><dl class="simple">
<dt>list<span class="classifier">string</span></dt><dd><p>list of hcm files with images to combine. The formats of the
images should all match</p>
</dd>
<dt>bias<span class="classifier">string</span></dt><dd><p>Name of bias frame to subtract, ‘none’ to ignore.</p>
</dd>
<dt>dark<span class="classifier">string</span></dt><dd><p>Name of dark frame to subtract, ‘none’ to ignore.</p>
</dd>
<dt>flat<span class="classifier">string</span></dt><dd><p>Name of flat field frame to subtract, ‘none’ to ignore.</p>
</dd>
<dt>method<span class="classifier">string</span></dt><dd><p>‘m’ for median, ‘c’ for clipped mean. See below for pros and cons.</p>
</dd>
<dt>sigma<span class="classifier">float [if method == ‘c’]</span></dt><dd><p>With clipped mean combination, pixels that deviate by more than
sigma RMS from the mean are kicked out. This is carried out in an
iterative manner. sigma &lt;= 0 implies no rejection, just a straight
average. sigma=3 is typical.</p>
</dd>
<dt>adjust<span class="classifier">string</span></dt><dd><p>adjustments to make: ‘i’ = ignore; ‘n’ = normalise the mean or
median of all frames to match the first; ‘b’ = add offsets so that
the mean or median of all frames is the same as the first. Option
‘n’ is useful for twilight flats and fringe frames; ‘b’ is good
for combining biases.</p>
</dd>
<dt>usemean<span class="classifier">bool [if adjust == ‘n’ or ‘b’]</span></dt><dd><p>True to use the mean rather than the median for normalisation or
biass offsetting.</p>
</dd>
<dt>plot<span class="classifier">bool [hidden, if adjust == ‘n’ or ‘b’; defaults to False]</span></dt><dd><p>make a plot of the mean versus frame number. This can provide a
quick check that the frames are not too different.</p>
</dd>
<dt>clobber<span class="classifier">bool [hidden]</span></dt><dd><p>clobber any pre-existing output files</p>
</dd>
<dt>output<span class="classifier">string</span></dt><dd><p>output file</p>
</dd>
</dl>
</div></blockquote>
<p>Clipped mean can work well for large numbers of frames but gets worse
for small numbers as the RMS can be heavily influenced by a single bad
value. The median can be better in such cases, but has the downside of
digitisation noise. For instance, the average of 100 bias frames could
have a noise level significantly below 1 count, depending upon the
readout noise, and the +/- 0.5 count uncertainty of median combination
may be worse than this.</p>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This routine reads all inputs into memory, so can be a bit of a
hog. However, it does so one CCD at a time to alleviate this. It will
fail if it cannot find a valid frame for any CCD.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.csub">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">csub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.csub" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">csub</span> <span class="pre">input</span> <span class="pre">const</span> <span class="pre">[ccd</span> <span class="pre">win]</span> <span class="pre">output</span></code></p>
<p>Subtracts a constant from a HiPERCAM hcm frame. Can be applied only to
particular CCDs and windows if wanted.</p>
<p>Parameters:</p>
<blockquote>
<div><dl class="simple">
<dt>input<span class="classifier">string</span></dt><dd><p>input hcm file name</p>
</dd>
<dt>const<span class="classifier">float</span></dt><dd><p>constant to subtract</p>
</dd>
<dt>ccd<span class="classifier">string [hidden, defaults to ‘all’]</span></dt><dd><p>the CCD or CCDs to apply the operation to. ‘all’ for the whole lot
which it returns to by default.  Can be several e.g. ‘2 4’ or just
one ‘3’</p>
</dd>
<dt>win<span class="classifier">string [hidden, defaults to ‘all’]</span></dt><dd><p>the CCD or CCDs to apply the operation to. ‘all’ for the whole lot
which it returns to by default.  Can be several e.g. ‘E2 G1’ or just
one ‘H1’. If you specify windows in this manner, it is assumed that
all the CCDs chosen in the previous input have the named windows;
‘all’ just applies the operation to all windows regardless.</p>
</dd>
<dt>output<span class="classifier">string</span></dt><dd><p>output hcm file name. Can be same as input in which case
the file will be over-written.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.div">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">div</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.div" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">div</span> <span class="pre">input1</span> <span class="pre">input2</span> <span class="pre">[ccd</span> <span class="pre">win]</span> <span class="pre">output</span></code></p>
<p>Divides two hcm frames and outputs the result. Can be applied only to
particular CCDs and windows if wanted.</p>
<p>Parameters:</p>
<blockquote>
<div><dl class="simple">
<dt>input1<span class="classifier">string</span></dt><dd><p>first input hcm file</p>
</dd>
<dt>input2<span class="classifier">string</span></dt><dd><p>second input hcm file to divide into the first.</p>
</dd>
<dt>ccd<span class="classifier">string [hidden, defaults to ‘all’]</span></dt><dd><p>the CCD or CCDs to apply the operation to. ‘all’ for the whole lot
which it returns to by default.  Can be several e.g. ‘2 4’ or just
one ‘3’</p>
</dd>
<dt>win<span class="classifier">string [hidden, defaults to ‘all’]</span></dt><dd><p>the CCD or CCDs to apply the operation to. ‘all’ for the whole lot
which it returns to by default.  Can be several e.g. ‘E2 G1’ or just
one ‘H1’. If you specify windows in this manner, it is assumed that
all the CCDs chosen in the previous input have the named windows;
‘all’ just applies the operation to all windows regardless.</p>
</dd>
<dt>output<span class="classifier">string</span></dt><dd><p>output hcm file name. Can be same as either input1 or input2
in which case the input file will be over-written.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.exploss">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">exploss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.exploss" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">exploss</span> <span class="pre">log</span> <span class="pre">[device]</span> <span class="pre">aper</span> <span class="pre">readout</span> <span class="pre">gain</span></code></p>
<p>Computes the equivalent exposure time needed to match the
signal-to-noise ratio of the current input log file as a fraction
of the actual exposure time, assuming one had an identical
detector except it had zero readout noise. The purpose of the
routine is to help in judging how readout noise limited a given
run is. The result is a loss factor between 0 and 1. If close to
1, readout noise is not significant. A value of 0.5 means that, in
the absence of readout noise, you could have achieved the same
signal-to-noise ratio in half the time you actually used. The
point is one can tilt towards effectively zero readnoise case by
exposing longer / reading out less often.</p>
<p>As well as the loss factor for the supplied run (plotted in blue),
the case for double the exposure time is plotted (in red). If this
is significantly larger than the blue values, it may be advisable
to increase the exposure time or add to NBLUE / NSKIP. Basically
you want all curves to be close to the upper level of 1, or you
are effectively throwing away time by reading out too often. Of
course you may have little choice, and so it is important to
consider what exposure time you really need.</p>
<p>The key determinant as to whether readout noise matters is how
the quantity n*gain*readout**2, where n = number of pixels in
target aperture, compares with obj+n*sky, where obj is the total
number of object counts in the aperture and sky in the sky
background per pixel (both ADU). Thus readout noise tends to be of
less significance during bright time, and seeing is important,
particularly during dark time, since that is what determines “n”.
Always remember, in very bad seeing, binning might be an option.</p>
<p>Arguments:</p>
<div class="highlight-rest notranslate"><div class="highlight"><pre><span></span>log : string
    name of |reduce| ASCII log file (text file with loads of columns)

device : string [hidden, defaults to &#39;term&#39;]
   &#39;term&#39; for interactive plot, file name such as &#39;plot.pdf&#39;
   for a hardcopy.

aper : str
   aperture to consider

readout : float
   readout noise, RMS ADU.

gain : float
   Gain,  electrons/ADU.
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The results from this script are <em>meaningless</em> if the data
were not bias-subtracted during <a class="reference internal" href="#hipercam.scripts.reduce" title="hipercam.scripts.reduce"><code class="xref py py-func docutils literal notranslate"><span class="pre">reduce</span></code></a>! You have been warned.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.fits2hcm">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">fits2hcm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.fits2hcm" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">fits2hcm</span> <span class="pre">flist</span> <span class="pre">origin</span></code></p>
<p>This routine converts “foreign” data into a format suitable for the
pipeline. HiPERCAM’s hcm files are in fact FITS-format so this is mostly
a case of re-organising the files.</p>
<p>Parameters:</p>
<blockquote>
<div><dl>
<dt>flist<span class="classifier">str</span></dt><dd><p>name of list of input FITS-format files.  ‘flist’ should end
‘.lis’. The output file names will have the same rootname as
the input files (but without any leading directories) but end
in ‘.hcm’</p>
</dd>
<dt>origin<span class="classifier">str</span></dt><dd><p>origin of the data. Currently recognised:</p>
<blockquote>
<div><dl class="simple">
<dt>HICKS :</dt><dd><p>University of Sheffield 16” Hicks Telescope
SBIG ST10-XME CCD</p>
</dd>
<dt>INTWFC :</dt><dd><p>Wide field Camera on the INT. Just operates on a single CCD’s-worth
of data.</p>
</dd>
<dt>LCOGT :</dt><dd><p>Las Cumbres Observatory, based on some FTN data taken in 2019.</p>
</dd>
<dt>LTIO :</dt><dd><p>Liverpool Telescope IO camera.</p>
</dd>
<dt>LTRISE :</dt><dd><p>Liverpool Telescope RISE camera. I don’t know how general my
code is in this case. I assume XBIN=YBIN=2.</p>
</dd>
<dt>PT5M :</dt><dd><p>University of Sheffield/Durham pt5m telescope on La Palma
QSI 532 CCD</p>
</dd>
<dt>ROSA :</dt><dd><p>University of Sheffield 10” Hicks Telescope
ATIK ONE 6.0 CCD</p>
</dd>
<dt>WHTCAM :</dt><dd><p>Camera used by Richard Ashley in Feb 2021.</p>
</dd>
<dt>OSIRIS+<span class="classifier"></span></dt><dd><p>Imager and spectrograph on the GTC. Added by Alex Brown in Nov 2023. 
Only tested with 2x2 binning and full frame</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>overwrite<span class="classifier">bool</span></dt><dd><p>overwrite files on output</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.flagcloud">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">flagcloud</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.flagcloud" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">flagcloud</span> <span class="pre">hlog</span> <span class="pre">aper1</span> <span class="pre">aper2</span> <span class="pre">ccd</span> <span class="pre">delta</span> <span class="pre">output</span></code></p>
<p>Interactive flagging of cloud-affected or otherwise bad points in
a HiPERCAM log file. You either mark a range of times as cloudy, or
individual points as junk. If you mark a range, then <em>all</em>
apertures of <em>all</em> CCDs will be flagged with the bitmask value
CLOUDS. Individual points will be flagged as JUNK. Note that
nothing is done to the data apart from changing the bitmask flags,
so it is then up to you to test for these later on. This also
means the flagging operation is easily reversible by clearing the
CLOUD and JUNK flags, e.g. by AND-ing the flags with ~JUNK and
~CLOUDS. It is also possible to flag individual points as CLOUDS
but these will not propagate across CCDs so it is probably not
advisable to do this. Similarly range can be flagged as JUNK
although it is unusual for all apertures of all CCDs to be junk,
although bad seeing / awful cloud can cause this.</p>
<p>Junk points are marked red, cloudy points orange. OK aperture 1
points are plotted green, aperture 2 blue, and their ratio
black. What is meant by ‘junk’ as opposed to ‘cloud’ is really
down to the user. I tend to reserve junk for one-off points
affected by bad cosmic rays and satellites, but in general it is
probably sensible to think of “junk” as points you never want to
see again versus “clouds” meaning data that you might want either
to mask or use down the line, but would would like some way to
know that it was affected by clouds. Some genuine “cloudy” data
will be so bad that it will be better flagged as junk however. You
can flag the same point as both “cloud” and “junk”, but “junk” is
the stronger condition.</p>
<p>Bitmasks propagate when data are combined so a point flagged junk in
aperture 2 but not aperture 1 will be flagged junk in the ratio of 1
divided by 2. You can also recover points in this routine; doing so will
clear both their junk and/or cloud status. At the moment this is only
possible on a point-by-point basis.</p>
<p>Interaction is via the cursor and hitting specific keys. Common
options are lower case; less common ones upper case. Hitting the X
on the plot will abort without saving the results. ‘q’ to quit
saves the results. ‘h’ gives further help on the options.</p>
<p>Parameters:</p>
<blockquote>
<div><dl class="simple">
<dt>hlog<span class="classifier">str</span></dt><dd><p>ASCII log file, as produced by <a class="reference internal" href="#hipercam.scripts.reduce" title="hipercam.scripts.reduce"><code class="xref py py-func docutils literal notranslate"><span class="pre">reduce</span></code></a>.</p>
</dd>
<dt>aper1<span class="classifier">str</span></dt><dd><p>the name of first aperture to look at</p>
</dd>
<dt>aper2<span class="classifier">str</span></dt><dd><p>the name of second aperture to look at. The ratio aper1 / aper2
will be plotted along with the two separately, scaled by their
maximum, all in the same panel.</p>
</dd>
<dt>ccd<span class="classifier">str</span></dt><dd><p>CCD(s) to plot, ‘0’ for all. If not ‘0’ then ‘1’, ‘2’, or even ‘1 2 3’
are possible inputs (without the quotes). Note the space separation when multiple
CCDs are specified. If you want to plot more than one CCD, then you will get multiple
panels in the Y direction, but their X-axes are kept in lock step when panning or zooming.</p>
</dd>
<dt>delta<span class="classifier">float</span></dt><dd><p>separation to use to space the plots in a given panel, each of which is normalised
to 1. A value of 1 is recommended because then the second aperture should end with
a typical level of 0, and any dips below this show the extent of the cloud. e.g. -0.9
would suggest an approximate 90% loss of flux due to cloud, ignoring extinction.</p>
</dd>
<dt>output<span class="classifier">str</span></dt><dd><p>name of modified version of the Hlog for output. Can overwrite the original if you dare.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.ftargets">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">ftargets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.ftargets" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">ftargets</span> <span class="pre">[source</span> <span class="pre">device</span> <span class="pre">width</span> <span class="pre">height]</span> <span class="pre">(run</span> <span class="pre">first</span> <span class="pre">[twait</span> <span class="pre">tmax]</span> <span class="pre">|</span>
<span class="pre">flist)</span> <span class="pre">trim</span> <span class="pre">([ncol</span> <span class="pre">nrow])</span> <span class="pre">(ccd</span> <span class="pre">(nx))</span> <span class="pre">[pause]</span> <span class="pre">thresh</span> <span class="pre">fwhm</span> <span class="pre">minpix</span>
<span class="pre">output</span> <span class="pre">bias</span> <span class="pre">flat</span> <span class="pre">msub</span> <span class="pre">iset</span> <span class="pre">(ilo</span> <span class="pre">ihi</span> <span class="pre">|</span> <span class="pre">plo</span> <span class="pre">phi)</span> <span class="pre">xlo</span> <span class="pre">xhi</span> <span class="pre">ylo</span> <span class="pre">yhi</span></code></p>
<p>This script carries out the following steps for each of a series
of images:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>detects the sources,</p></li>
<li><p>identifies isolated targets suited to profile fits,</p></li>
<li><p>fits 2D Moffat profiles to these,</p></li>
<li><p>Saves results to disk.</p></li>
</ol>
</div></blockquote>
<p>The profile fits are carried out because <cite>sep</cite> does not return
anything that can be used reliably for a FWHM.</p>
<p>Several parameters depends on the object detection threshold
retuned by the source detection. This is referred to as
<cite>threshold</cite>. The source detection is carried out using <cite>sep</cite> which
runs according to the usual source extractor algorithm of Bertin.</p>
<p>The script plots the frames, with ellipses at 3*a,3*b indicated in
red, green boxes indicating the range of pixels identified by
<cite>sep</cite>, and blue boxes marking the targets selected for FWHM
fitting (the boxes indicate the fit region).</p>
<p>Parameters:</p>
<blockquote>
<div><dl>
<dt>source<span class="classifier">string [hidden]</span></dt><dd><p>Data source, five options:</p>
<blockquote>
<div><div class="line-block">
<div class="line">‘hs’ : HiPERCAM server</div>
<div class="line">‘hl’ : local HiPERCAM FITS file</div>
<div class="line">‘us’ : ULTRACAM server</div>
<div class="line">‘ul’ : local ULTRACAM .xml/.dat files</div>
<div class="line">‘hf’ : list of HiPERCAM hcm FITS-format files</div>
</div>
</div></blockquote>
<p>‘hf’ is used to look at sets of frames generated by ‘grab’
or converted from foreign data formats. The standard
start-off default for <code class="docutils literal notranslate"><span class="pre">source</span></code> can be set using the
environment variable HIPERCAM_DEFAULT_SOURCE. e.g. in bash
<code class="code docutils literal notranslate"><span class="pre">export</span> <span class="pre">HIPERCAM_DEFAULT_SOURCE=&quot;us&quot;</span></code> would ensure it
always started with the ULTRACAM server by default. If
unspecified, it defaults to ‘hl’.</p>
</dd>
<dt>device<span class="classifier">string [hidden]</span></dt><dd><p>Plot device. PGPLOT is used so this should be a PGPLOT-style name,
e.g. ‘/xs’, ‘1/xs’ etc. At the moment only ones ending /xs are
supported.</p>
</dd>
<dt>width<span class="classifier">float [hidden]</span></dt><dd><p>plot width (inches). Set = 0 to let the program choose.</p>
</dd>
<dt>height<span class="classifier">float [hidden]</span></dt><dd><p>plot height (inches). Set = 0 to let the program choose. BOTH width
AND height must be non-zero to have any effect</p>
</dd>
<dt>run<span class="classifier">string [if source ends ‘s’ or ‘l’]</span></dt><dd><p>run number to access, e.g. ‘run034’</p>
</dd>
<dt>flist<span class="classifier">string [if source ends ‘f’]</span></dt><dd><p>name of file list</p>
</dd>
<dt>first<span class="classifier">int [if source ends ‘s’ or ‘l’]</span></dt><dd><p>exposure number to start from. 1 = first frame; set = 0 to always
try to get the most recent frame (if it has changed).  For data
from the HiPERCAM server, a negative number tries to get a frame not
quite at the end.  i.e. -10 will try to get 10 from the last
frame. This is mainly to sidestep a difficult bug with the
acquisition system.</p>
</dd>
<dt>twait<span class="classifier">float [if source ends ‘s’ or ‘l’; hidden]</span></dt><dd><p>time to wait between attempts to find a new exposure, seconds.</p>
</dd>
<dt>tmax<span class="classifier">float [if source ends ‘s’ or ‘l’; hidden]</span></dt><dd><p>maximum time to wait between attempts to find a new exposure,
seconds.</p>
</dd>
<dt>trim<span class="classifier">bool [if source starts with ‘u’]</span></dt><dd><p>True to trim columns and/or rows off the edges of windows nearest
the readout which can sometimes contain bad data.</p>
</dd>
<dt>ncol<span class="classifier">int [if trim, hidden]</span></dt><dd><p>Number of columns to remove (on left of left-hand window, and right
of right-hand windows)</p>
</dd>
<dt>nrow<span class="classifier">int [if trim, hidden]</span></dt><dd><p>Number of rows to remove (bottom of windows)</p>
</dd>
<dt>ccd<span class="classifier">string</span></dt><dd><p>CCD(s) to plot, ‘0’ for all, ‘1 3’ to plot ‘1’ and ‘3’ only, etc.</p>
</dd>
<dt>nx<span class="classifier">int [if more than 1 CCD]</span></dt><dd><p>number of panels across to display.</p>
</dd>
<dt>pause<span class="classifier">float [hidden]</span></dt><dd><p>seconds to pause between frames (defaults to 0)</p>
</dd>
<dt>thresh<span class="classifier">float</span></dt><dd><p>threshold (mutiple of RMS) to use for object detection. Typical
values 2.5 to 4. The higher it is, the fewer objects will be located,
but the fewer false detections will be made.</p>
</dd>
<dt>fwhm<span class="classifier">float</span></dt><dd><p>FWHM to use for smoothing during object detection. Should be
comparable to the seeing.</p>
</dd>
<dt>minpix<span class="classifier">int</span></dt><dd><p>Minimum number of pixels above threshold before convolution to count
as a detection. Useful in getting rid of cosmics and high dark count
pixels.</p>
</dd>
<dt>rmin<span class="classifier">float</span></dt><dd><p>Closest distance of any other detected object for an attempt
to be made to fit the FWHM of an object [unbinned pixels].</p>
</dd>
<dt>pmin<span class="classifier">float</span></dt><dd><p>Minimum peak height for an attempt to be made to fit the
FWHM of an object. This should be a multiple of the object
detection threshold (returned by <cite>sep</cite> for each object).</p>
</dd>
<dt>pmax<span class="classifier">float</span></dt><dd><p>Maximum peak height for an attempt to be made to fit the
FWHM of an object. Use to exclude saturated targets
[counts]</p>
</dd>
<dt>emax<span class="classifier">float</span></dt><dd><p>Maximum elongation (major/minor axis ratio = a/b), &gt; 1. Use
to reduce very non-stellar profiles.</p>
</dd>
<dt>nmax<span class="classifier">int</span></dt><dd><p>Maximum number of FWHMs to measure. Will take the brightest first,
judging by the flux.</p>
</dd>
<dt>bias<span class="classifier">string</span></dt><dd><p>Name of bias frame to subtract, ‘none’ to ignore.</p>
</dd>
<dt>flat<span class="classifier">string</span></dt><dd><p>Name of flat field to divide by, ‘none’ to ignore. Should normally
only be used in conjunction with a bias, although it does allow you
to specify a flat even if you haven’t specified a bias.</p>
</dd>
<dt>output: string</dt><dd><p>Name of file for storage of results. Will be a fits file, with
results saved to the HDU 1 as a table.</p>
</dd>
<dt>iset<span class="classifier">string [single character]</span></dt><dd><p>determines how the intensities are determined. There are three
options: ‘a’ for automatic simply scales from the minimum to the
maximum value found on a per CCD basis. ‘d’ for direct just takes
two numbers from the user. ‘p’ for percentile dtermines levels
based upon percentiles determined from the entire CCD on a per CCD
basis.</p>
</dd>
<dt>ilo<span class="classifier">float [if iset=’d’]</span></dt><dd><p>lower intensity level</p>
</dd>
<dt>ihi<span class="classifier">float [if iset=’d’]</span></dt><dd><p>upper intensity level</p>
</dd>
<dt>plo<span class="classifier">float [if iset=’p’]</span></dt><dd><p>lower percentile level</p>
</dd>
<dt>phi<span class="classifier">float [if iset=’p’]</span></dt><dd><p>upper percentile level</p>
</dd>
<dt>xlo<span class="classifier">float</span></dt><dd><p>left-hand X-limit for plot</p>
</dd>
<dt>xhi<span class="classifier">float</span></dt><dd><p>right-hand X-limit for plot (can actually be &lt; xlo)</p>
</dd>
<dt>ylo<span class="classifier">float</span></dt><dd><p>lower Y-limit for plot</p>
</dd>
<dt>yhi<span class="classifier">float</span></dt><dd><p>upper Y-limit for plot (can be &lt; ylo)</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.genred">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">genred</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.genred" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">genred</span> <span class="pre">apfile</span> <span class="pre">rfile</span> <span class="pre">bias</span> <span class="pre">dark</span> <span class="pre">flat</span> <span class="pre">fmap</span> <span class="pre">fpair</span> <span class="pre">seeing</span> <span class="pre">(sworst</span>
<span class="pre">binfac)</span> <span class="pre">template</span> <span class="pre">(inst</span> <span class="pre">(nccd</span> <span class="pre">(ccd)</span> <span class="pre">nonlin</span> <span class="pre">sat</span> <span class="pre">scale</span> <span class="pre">readout</span>
<span class="pre">gain))</span></code></p>
<p>Generates a reduce file as needed by <a class="reference internal" href="#hipercam.scripts.reduce" title="hipercam.scripts.reduce"><code class="xref py py-func docutils literal notranslate"><span class="pre">reduce</span></code></a>. You
give it the name of an aperture file, calibration frames and a few
other parameters and it will write out a reduce file which you can
then refine by hand. The aim is to try to get a reduce file that
is self-consistent and works to get observing started as soon as
possible. The parameters are not necessarily the best.</p>
<p>It is assumed that the target is called ‘1’, the main comparison ‘2’.</p>
<p>To avoid endless prompts, genred does not try to prompt for all
parameters even via hidden ones (a change from its previous
behaviour).  However, if you find yourself always making the samed
edits to the file produced by genred, you may start wanting a way
to alter some of the otherwise fixed parameters. You can do so by
supplying a template file, which can just be from a previous run
of genred where such parameters can be altered by editing with a
standard text editor before running genred.</p>
<p>genred recognises some standard instrument telescope combinations
which it uses to set parameters such as the pixel scale and
readout noise, but if you choose ‘other’, you will be prompted for
these details. The main parameters it does prompt for are
calibration files, and it allows you to define a “seeing” which
then controls the setting of various profile fit parameters. This
can be ignored by setting = 0, in which case any template
parameters will be passed unchanged.</p>
<p>Parameters:</p>
<blockquote>
<div><dl class="simple">
<dt>apfile<span class="classifier">str</span></dt><dd><p>the input aperture file created using <a class="reference internal" href="#hipercam.scripts.setaper" title="hipercam.scripts.setaper"><code class="xref py py-func docutils literal notranslate"><span class="pre">setaper</span></code></a> (default
extension .ape). This will be read for the targets. The
main target will be assumed to have been called ‘1’, the
main comparison ‘2’. If there is a ‘3’ it will be plotted
relative to ‘2’; all others will be ignored for plotting
purposes. Target ‘2’ will be used to define the position
and transmission plots for one CCD only [user
definable]. Target ‘1’ will be used for the seeing plot
unless it is linked when target ‘2’ will be used instead.</p>
</dd>
<dt>rfile<span class="classifier">str</span></dt><dd><p>the output reduce file created by this script. The main
target will be assumed to have been called ‘1’, the main
comparison ‘2’. If there is a ‘3’ it will be plotted
relative to ‘2’; all others will be ignored for plotting
purposes.</p>
</dd>
<dt>bias<span class="classifier">str</span></dt><dd><p>Name of bias frame; ‘none’ to ignore.</p>
</dd>
<dt>dark<span class="classifier">str</span></dt><dd><p>Name of dark frame; ‘none’ to ignore.</p>
</dd>
<dt>flat<span class="classifier">str</span></dt><dd><p>Name of flat field frame; ‘none’ to ignore.</p>
</dd>
<dt>fmap<span class="classifier">str</span></dt><dd><p>Name of fringe frame; ‘none’ to ignore.</p>
</dd>
<dt>fpair<span class="classifier">str [if fmap not ‘none’]</span></dt><dd><p>File defining pairs to measure fringe amplitudes.</p>
</dd>
<dt>seeing<span class="classifier">float</span></dt><dd><p>estimate of seeing which will be used to define several of
the profile fitting parameters. Enter 0 to ignore and use
defaults from the template (or genred if no template)
instead.</p>
</dd>
<dt>sworst<span class="classifier">float [if seeing &gt; 0]</span></dt><dd><p>worst seeing expected during run. Expands the search and
fitting boxes which can cause difficulties if they are
too small. It also sets the maximum target aperture radius
which will set to ~ 1.8*sworst, converted to pixels, and the
sky annulus radii. It has to be at least 2*seeing. Always
remember that you can override the automated settings using
a pre-edited template and seeing = 0.</p>
</dd>
<dt>binfac<span class="classifier">int [if seeing &gt; 0]</span></dt><dd><p>binning factor. e.g. 4 if using 4x4. Needed to optimise some
profile parameters.</p>
</dd>
<dt>template<span class="classifier">str</span></dt><dd><p>Reduce file to use as a template for any parameters not set
by genred. This allows one to tweak settings by running
genred without a template, then modifying the resultant
file and using it as a template. ‘none’ to ignore, and then
these values will be set by genred by default. Some will be
modified anyway (e.g. the calibration file names), and if
seeing &gt; 0, then several of the profile fitting paramaters
will be adapted to the value given along with the
instrument parameters.  genred will try to keep as many of
the ‘extraction’, ‘position’, ‘transmission’, ‘light’ etc
lines associated with particular CCDs in this case without
modification, and will pass readout, saturation levels etc
unchanged from the template.</p>
</dd>
<dt>inst<span class="classifier">str [if template == ‘none’]</span></dt><dd><p>the instrument. ‘hipercam-gtc’, ‘ultracam-ntt’, ‘ultraspec-tnt’,
‘ultracam-wht’, ‘ultracam-vlt’,  or ‘other’. Sets pixel scale and
standard readnoise params.</p>
</dd>
<dt>nccd<span class="classifier">int [if inst == ‘other’]</span></dt><dd><p>number of CCDs.</p>
</dd>
<dt>ccd<span class="classifier">int [if nccd &gt; 1]</span></dt><dd><p>the CCD to use for position plots</p>
</dd>
<dt>nonlin<span class="classifier">list(float) [if inst == ‘other’]</span></dt><dd><p>values for warning of non linearity</p>
</dd>
<dt>sat<span class="classifier">list(float) [if inst == ‘other’]</span></dt><dd><p>values for warning of saturation</p>
</dd>
<dt>scale<span class="classifier">float [if inst == ‘other’]</span></dt><dd><p>image scale in arcsec/pixel</p>
</dd>
<dt>readout<span class="classifier">float | string [if inst == ‘other’]</span></dt><dd><p>readout noise, RMS ADU. Can either be a single value or an
hcm file.</p>
</dd>
<dt>gain<span class="classifier">float | string [if inst == ‘other’]</span></dt><dd><p>gain, electrons per ADU. Can either be a single value or an
hcm file.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.grab">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">grab</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.grab" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">grab</span> <span class="pre">[source</span> <span class="pre">temp]</span> <span class="pre">(run</span> <span class="pre">first</span> <span class="pre">last</span> <span class="pre">(ndigit)</span> <span class="pre">[twait</span> <span class="pre">tmax]</span> <span class="pre">|</span> <span class="pre">flist</span>
<span class="pre">(prefix))</span> <span class="pre">trim</span> <span class="pre">([ncol</span> <span class="pre">nrow])</span> <span class="pre">bias</span> <span class="pre">dark</span> <span class="pre">flat</span> <span class="pre">fmap</span> <span class="pre">(fpair</span> <span class="pre">[nhalf</span> <span class="pre">rmin</span>
<span class="pre">rmax</span> <span class="pre">verbose])</span> <span class="pre">[dtype]</span></code></p>
<p>This downloads a sequence of images from a raw data file and writes them
out to a series CCD / MCCD files.</p>
<p>Parameters:</p>
<blockquote>
<div><dl>
<dt>source<span class="classifier">str [hidden]</span></dt><dd><p>Data source, four options:</p>
<blockquote>
<div><div class="line-block">
<div class="line">‘hs’ : HiPERCAM server</div>
<div class="line">‘hl’ : local HiPERCAM FITS file</div>
<div class="line">‘us’ : ULTRACAM server</div>
<div class="line">‘ul’ : local ULTRACAM .xml/.dat files</div>
<div class="line">‘hf’ : list of HiPERCAM hcm FITS-format files</div>
</div>
</div></blockquote>
<p>The standard start-off default for <code class="docutils literal notranslate"><span class="pre">source</span></code> can be set
using the environment variable
HIPERCAM_DEFAULT_SOURCE. e.g. in bash <code class="code docutils literal notranslate"><span class="pre">export</span>
<span class="pre">HIPERCAM_DEFAULT_SOURCE=&quot;us&quot;</span></code> would ensure it always
started with the ULTRACAM server by default. If
unspecified, it defaults to ‘hl’. ‘hf’ is useful if you
want to apply pipeline calibrations (bias, flat, etc) to
files imported from a ‘foreign’ format. In this case the
output files will have the same name as the inputs but
with a prefix added.</p>
</dd>
<dt>temp<span class="classifier">bool [hidden, defaults to False]</span></dt><dd><p>True to indicate that the frames should be written to
temporary files with automatically-generated names in the
expectation of deleting them later. This also writes out a
file listing the names.  The aim of this is to allow grab
to be used as a feeder for other routines in larger
scripts.  If temp == True, grab will return with the name
of the list of hcm files. Look at ‘makebias’ for an example
that uses this feature.</p>
</dd>
<dt>run<span class="classifier">str [if source ends ‘s’ or ‘l’]</span></dt><dd><p>run number to access, e.g. ‘run034’</p>
</dd>
<dt>first<span class="classifier">int [if source ends ‘s’ or ‘l’]</span></dt><dd><p>First frame to access</p>
</dd>
<dt>last<span class="classifier">int [if source ends ‘s’ or ‘l’]</span></dt><dd><p>Last frame to access, 0 for the lot</p>
</dd>
<dt>ndigit<span class="classifier">int [if source ends ‘s’ or ‘l’ and not temp]</span></dt><dd><p>Files created will be written as ‘run005_0013.fits’
etc. <cite>ndigit</cite> is the number of digits used for the frame
number (4 in this case). Any pre-existing files of the same
name will be over-written.</p>
</dd>
<dt>twait<span class="classifier">float [hidden]</span></dt><dd><p>time to wait between attempts to find a new exposure, seconds.</p>
</dd>
<dt>tmax<span class="classifier">float [hidden]</span></dt><dd><p>maximum time to wait between attempts to find a new exposure,
seconds.</p>
</dd>
<dt>flist<span class="classifier">str [if source ends ‘f’]</span></dt><dd><p>name of file list. Output files will have the same names
as the input files with a prefix added</p>
</dd>
<dt>prefix<span class="classifier">str [if source ends ‘f’ and not temp]</span></dt><dd><p>prefix to add to create output file names</p>
</dd>
<dt>trim<span class="classifier">bool</span></dt><dd><p>True to trim columns and/or rows off the edges of windows
nearest the readout. Particularly useful for ULTRACAM
windowed data where the first few rows and columns can
contain bad data.</p>
</dd>
<dt>ncol<span class="classifier">int [if trim, hidden]</span></dt><dd><p>Number of columns to remove (on left of left-hand window,
and right of right-hand windows)</p>
</dd>
<dt>nrow<span class="classifier">int [if trim, hidden]</span></dt><dd><p>Number of rows to remove (bottom of windows)</p>
</dd>
<dt>bias<span class="classifier">str</span></dt><dd><p>Name of bias frame to subtract, ‘none’ to ignore.</p>
</dd>
<dt>dark<span class="classifier">str</span></dt><dd><p>Name of dark frame, ‘none’ to ignore.</p>
</dd>
<dt>flat<span class="classifier">str</span></dt><dd><p>Name of flat field to divide by, ‘none’ to ignore. Should normally
only be used in conjunction with a bias, although it does allow you
to specify a flat even if you haven’t specified a bias.</p>
</dd>
<dt>fmap<span class="classifier">str</span></dt><dd><p>Name of fringe map (see e.g. <cite>makefringe</cite>), ‘none’ to ignore.</p>
</dd>
<dt>fpair<span class="classifier">str [if fmap is not ‘none’]</span></dt><dd><p>Name of fringe pair file (see e.g. <cite>setfringe</cite>). Required if
a fringe map has been specified.</p>
</dd>
<dt>nhalf<span class="classifier">int [if fmap is not ‘none’, hidden]</span></dt><dd><p>When calculating the differences for fringe measurement,
a region extending +/-nhalf binned pixels will be used when
measuring the amplitudes. Basically helps the stats.</p>
</dd>
<dt>rmin<span class="classifier">float [if fmap is not ‘none’, hidden]</span></dt><dd><p>Minimum individual ratio to accept prior to calculating the overall
median in order to reduce the effect of outliers. Although all ratios
should be positive, you might want to set this a little below zero
to allow for some statistical fluctuation.</p>
</dd>
<dt>rmax<span class="classifier">float [if fmap is not ‘none’, hidden]</span></dt><dd><p>Maximum individual ratio to accept prior to calculating the overall
median in order to reduce the effect of outliers. Probably typically
&lt; 1 if fringe map was created from longer exposure data.</p>
</dd>
<dt>verbose<span class="classifier">bool</span></dt><dd><p>True to print lots of details of fringe ratios</p>
</dd>
<dt>dtype<span class="classifier">string [hidden, defaults to ‘f32’]</span></dt><dd><p>Data type on output. Options:</p>
<blockquote>
<div><div class="line-block">
<div class="line">‘f32’ : output as 32-bit floats (default)</div>
</div>
<div class="line-block">
<div class="line">‘f64’ : output as 64-bit floats.</div>
</div>
<div class="line-block">
<div class="line">‘u16’ : output as 16-bit unsigned integers. A warning will be
issued if loss of precision occurs; an exception will
be raised if the data are outside the range 0 to 65535.</div>
</div>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference internal" href="#hipercam.scripts.grab" title="hipercam.scripts.grab"><code class="xref py py-func docutils literal notranslate"><span class="pre">grab</span></code></a> is used by several other scripts such as <a class="reference internal" href="#hipercam.scripts.averun" title="hipercam.scripts.averun"><code class="xref py py-func docutils literal notranslate"><span class="pre">averun</span></code></a> so take great
care when changing anything to do with its input parameters.</p>
<p>If you use the “temp” option to write to temporary files, then those
files will be deleted if you interrup with CTRL-C. This is to prevent
the accumulation of such frames.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.hfilter">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">hfilter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.hfilter" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">hfilter</span> <span class="pre">input</span> <span class="pre">ccd</span> <span class="pre">nx</span> <span class="pre">filter</span> <span class="pre">[fwhm]</span> <span class="pre">output</span></code></p>
<p>Filters a multi-CCD image. e.g. smooths it. Can be useful
in some analysis steps, e.g. for picking out defects, division
by a smoother version of an image can be useful.</p>
<p>Parameters:</p>
<blockquote>
<div><dl class="simple">
<dt>input<span class="classifier">string</span></dt><dd><p>name of MCCD input file</p>
</dd>
<dt>ccd<span class="classifier">string</span></dt><dd><p>CCD(s) to filter, ‘0’ for all. If not ‘0’ then ‘1’, ‘2’ or even ‘3 4’
are possible inputs (without the quotes).</p>
</dd>
<dt>filter<span class="classifier">string [single character]</span></dt><dd><p>type of filter. ‘g’ = gaussian. Uses an FFT-based approach which
regards the boundaries as periodic, so you will get significant
edge-effects if the values on opposite edges of a window are
significantly different from each other.</p>
</dd>
<dt>clobber<span class="classifier">bool [hidden]</span></dt><dd><p>clobber any pre-existing output files</p>
</dd>
<dt>output<span class="classifier">string</span></dt><dd><p>name of MCCD output file</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.hinfo">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">hinfo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.hinfo" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">hinfo</span> <span class="pre">input</span></code></p>
<p>Prints out an hcm file along with its name and the number of CCDs. You
will get information CCD-by-CCD first followed by the top level header.
You will also get at least partial printouts of the data arrays. If
you want still more detail, I recommend the FITS viewer tool ‘fv’, or
‘ds9’ for examining images (also :hplot:).</p>
<p>Parameters:</p>
<blockquote>
<div><dl class="simple">
<dt>input<span class="classifier">string</span></dt><dd><p>name of the MCCD file</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.hist">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">hist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.hist" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">hist</span> <span class="pre">ccd</span> <span class="pre">window</span> <span class="pre">x1</span> <span class="pre">x2</span> <span class="pre">nbins</span> <span class="pre">gplot</span> <span class="pre">(nx)</span> <span class="pre">msub</span> <span class="pre">(nint)</span> <span class="pre">[device</span> <span class="pre">width</span>
<span class="pre">height]</span></code></p>
<p>Plots histograms of <code class="xref py py-class docutils literal notranslate"><span class="pre">MCCD</span></code> objects. Histograms can be powerful
diagnostics of CCD problems.</p>
<p>Parameters:</p>
<blockquote>
<div><dl class="simple">
<dt>input<span class="classifier">str</span></dt><dd><p>name of the MCCD file</p>
</dd>
<dt>ccd<span class="classifier">str</span></dt><dd><p>CCD or CCDs to plot in histogram form, one CCD per panel. Can be ‘0’
for all of them or a specific set ‘2 3 5’</p>
</dd>
<dt>window<span class="classifier">str</span></dt><dd><p>the window label to show. ‘0’ will merge all windows on each CCD.</p>
</dd>
<dt>x1<span class="classifier">float</span></dt><dd><p>lower end of histogram range</p>
</dd>
<dt>x2<span class="classifier">float</span></dt><dd><p>upper end of histoigram range. Set == x1 to get automatic min to max.</p>
</dd>
<dt>nbins<span class="classifier">int</span></dt><dd><p>number of bins to use for the histogram</p>
</dd>
<dt>ymax<span class="classifier">float</span></dt><dd><p>maximum y value for plot; 0 for automatic</p>
</dd>
<dt>gplot<span class="classifier">bool</span></dt><dd><p>plot a gaussian of the same mean and RMS as the data. Note
this is not a fit.</p>
</dd>
<dt>nx<span class="classifier">int</span></dt><dd><p>number of panels across to display, prompted if more than one CCD is
to be plotted.</p>
</dd>
<dt>msub<span class="classifier">bool</span></dt><dd><p>True/False to subtract median from each window before scaling</p>
</dd>
<dt>nint<span class="classifier">bool [if msub]</span></dt><dd><p>True/False to take the nearest integer of the median or not. Can help
with histograms of digitised data.</p>
</dd>
<dt>device<span class="classifier">str [hidden]</span></dt><dd><p>Plot device name. Either ‘term’ for an interactive plot or a
name like ‘plot.pdf’ for a hard copy.</p>
</dd>
<dt>width<span class="classifier">float [hidden]</span></dt><dd><p>plot width (inches). Set = 0 to let the program choose.</p>
</dd>
<dt>height<span class="classifier">float [hidden]</span></dt><dd><p>plot height (inches). Set = 0 to let the program choose. BOTH width
AND height must be non-zero to have any effect</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.hlog2col">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">hlog2col</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.hlog2col" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">hlog2col</span> <span class="pre">log</span> <span class="pre">ap1</span> <span class="pre">ap2</span></code></p>
<p>Converts a HiPERCAM ASCII log into one or more column format files
of one aperture versus another for each CCD. This tacks on the date
of the start of the night in order to distinguish run log names of the
the same number.</p>
<p>Parameters:</p>
<blockquote>
<div><dl class="simple">
<dt>log<span class="classifier">str</span></dt><dd><p>name of the log file (should end .log). The output FITS file
will have the same root name but end .fits. The routine will
abort if there is a pre-existing file of the same name.</p>
</dd>
<dt>origin<span class="classifier">str</span></dt><dd><p>‘h’ or ‘u’ depending upon whether the log file was created with
the hipercam or old ultracam pipeline.</p>
</dd>
<dt>offset :float [hidden]</dt><dd><p>offset in days to subtract from first time to get date at start
of the night. 0.7 should mostly work. offset is subtracted and
the MJD truncated to integer</p>
</dd>
<dt>ap1<span class="classifier">str</span></dt><dd><p>name of first aperture</p>
</dd>
<dt>ap2<span class="classifier">str</span></dt><dd><p>name of second aperture</p>
</dd>
<dt>type<span class="classifier">str</span></dt><dd><p>output type ‘l’ for linear; ‘m’ for magnitudes. Linear has the
advantage of handling negative values.</p>
</dd>
</dl>
</div></blockquote>
<p>The output files will get names like 2021-01-12_run014_2_3_4.dat meaning
CCD 2, aperture 3 divided by 4 of run014 from the night starting 2021-01-12.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.hlog2fits">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">hlog2fits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.hlog2fits" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">hlog2fits</span> <span class="pre">log</span> <span class="pre">[origin</span> <span class="pre">dir]</span></code></p>
<p>Converts a HiPERCAM ASCII log into a FITS file. As well as a modest
reduction in file size (~40%, the ASCII logs are written relatively
efficiently), the resulting file is faster to read than the ASCII log
so this may be useful for very large log files [test of 78,000 frame file:
12.9 seconds to read the ASCII file, 1.9 to read the FITS version]. The FITS
log is also much easier to understand than the ASCII files, but they don’t
have all the header information, so are not a replacement. At the
moment no significant header information is transferred beyond the CCD
names. Each CCD appears as a single binary table, starting at the second
HDU (or HDU 1 if you number them 0,1,2 ..). This can be read using
<code class="xref py py-meth docutils literal notranslate"><span class="pre">hipercam.hlog.Hlog.from_fits()</span></code>.</p>
<p>Parameters:</p>
<blockquote>
<div><dl class="simple">
<dt>log<span class="classifier">str</span></dt><dd><p>name of the log file (should end .log). The output FITS file
will have the same root name but end .fits. The routine will abort
if there is a pre-existing file of the same name.</p>
</dd>
<dt>origin<span class="classifier">str [hidden]</span></dt><dd><p>‘h’ or ‘u’ depending upon whether the log file was created with
the hipercam or old ultracam pipeline. Defaults to ‘h’.</p>
</dd>
<dt>dir<span class="classifier">str [hidden]</span></dt><dd><p>directory for the output; defaults to the present working directory</p>
</dd>
</dl>
</div></blockquote>
<p>NB Because of the danger of over-writing raw data (also ends
.fits), this routine will not over-write pre-existing files. You
should delete clashing files if you really want to proceed.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.hls">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">hls</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.hls" title="Link to this definition">¶</a></dt>
<dd><p>Gives an ‘ls’-like listing of the runs available on the HiPERCAM file
server. Just invoke as ‘hls’ with no arguments. This should work correctly
whether it in fact its the HiPERCAM or ULTRACAM file server that is
running.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.hplot">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">hplot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.hplot" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">hplot</span> <span class="pre">input</span> <span class="pre">[device]</span> <span class="pre">ccd</span> <span class="pre">nx</span> <span class="pre">msub</span> <span class="pre">([cmap])</span> <span class="pre">hsbox</span> <span class="pre">iset</span> <span class="pre">(ilo</span> <span class="pre">ihi</span> <span class="pre">|</span> <span class="pre">plo</span>
<span class="pre">phi)</span> <span class="pre">xlo</span> <span class="pre">xhi</span> <span class="pre">ylo</span> <span class="pre">yhi</span> <span class="pre">[width</span> <span class="pre">height]</span></code></p>
<p>Plots a multi-CCD image. Can use PGPLOT or matplotlib. The matplotlib
version is slightly clunky in its choice of the viewing area but has some
features that could be useful, in particular, the interactive plot
(device=’/mpl’) allows one to pan and zoom and to compare the same part of
multiple CCDs easily.</p>
<p>If the interactive plot is used (device=’/mpl’), then pressing the space
bar will initiate a profile fit at the position of the cursor. The
parameters of a successfull fit will be printed to the screen.
A radial profile plot centered on the fit position can be plotted
by pressing the ‘r’ key. This will open a new matplotlib window.</p>
<p>Parameters:</p>
<blockquote>
<div><dl>
<dt>input<span class="classifier">string</span></dt><dd><p>name of MCCD file</p>
</dd>
<dt>device<span class="classifier">string [hidden]</span></dt><dd><p>Plot device name. Uses characters after a final trailing ‘/’ to
identify the type in PGPLOT style. Thus:</p>
<blockquote>
<div><div class="line-block">
<div class="line">/xs : PGPLOT xserver interactive plot</div>
<div class="line">1/xs : PGPLOT xserver interactive plot called ‘1’</div>
<div class="line">plot.ps/cps : PGPLOT colour postscript called ‘plot.ps’</div>
<div class="line">plot.ps/vps : PGPLOT B&amp;W portrait oriented plot</div>
<div class="line">/mpl : matplotlib interactive plot</div>
<div class="line">plot.pdf/mpl : matplotlib PDF plot</div>
</div>
</div></blockquote>
</dd>
<dt>ccd<span class="classifier">string</span></dt><dd><p>CCD(s) to plot, ‘0’ for all. If not ‘0’ then ‘1’, ‘2’ or even ‘3 4’
are possible inputs (without the quotes). ‘3 4’ will plot CCD ‘3’ and
CCD ‘4’. If you want to plot more than one CCD, then you will be
prompted for the number of panels in the X direction. This parameter
will not be prompted if there is only one CCD in the file.</p>
</dd>
<dt>nx<span class="classifier">int</span></dt><dd><p>number of panels across to display, prompted if more than one CCD is
to be plotted.</p>
</dd>
<dt>msub<span class="classifier">bool</span></dt><dd><p>True/False to subtract median from each window before scaling</p>
</dd>
<dt>cmap<span class="classifier">str [if matplotlib; hidden]</span></dt><dd><p>The colour map to use. “Greys” is the usual, but there are
many others. Typing an incorrect one will give a list. “none”
for matplotlib default.</p>
</dd>
<dt>hsbox<span class="classifier">int [if device = ‘/mpl’; hidden]</span></dt><dd><p>half-width in binned pixels of stats box as offset from central pixel
hsbox = 1 gives a 3x3 box; hsbox = 2 gives 5x5 etc.</p>
</dd>
<dt>iset<span class="classifier">string [single character]</span></dt><dd><p>determines how the intensities are determined. There are three
options: ‘a’ for automatic simply scales from the minimum to the
maximum value found on a per CCD basis. ‘d’ for direct just takes two
numbers from the user. ‘p’ for percentile dtermines levels based upon
percentiles determined from the entire CCD on a per CCD bais.</p>
</dd>
<dt>ilo<span class="classifier">float [if iset==’d’]</span></dt><dd><p>lower intensity level</p>
</dd>
<dt>ihi<span class="classifier">float [if iset==’d’]</span></dt><dd><p>upper intensity level</p>
</dd>
<dt>plo<span class="classifier">float [if iset==’p’]</span></dt><dd><p>lower percentile level</p>
</dd>
<dt>phi<span class="classifier">float [if iset==’p’]</span></dt><dd><p>upper percentile level</p>
</dd>
<dt>xlo<span class="classifier">float</span></dt><dd><p>left X-limit, for PGPLOT plots. Applies to matplotlib plots
to restrict region used to compute percentile limits. This is
useful in case where bias strips otherwise distort the plot
limits (e.g. ultraspec full frame images)</p>
</dd>
<dt>xhi<span class="classifier">float</span></dt><dd><p>right X-limit. See comments for xlo as well.</p>
</dd>
<dt>ylo<span class="classifier">float</span></dt><dd><p>bottom Y-limit. See comments for xlo as well.</p>
</dd>
<dt>yhi<span class="classifier">float</span></dt><dd><p>top Y-limit. See comments for xlo as well.</p>
</dd>
<dt>width<span class="classifier">float [hidden]</span></dt><dd><p>plot width (inches). Set = 0 to let the program choose.</p>
</dd>
<dt>height<span class="classifier">float [hidden]</span></dt><dd><p>plot height (inches). Set = 0 to let the program choose. BOTH width
AND height must be non-zero to have any effect</p>
</dd>
<dt>method<span class="classifier">str [hidden]</span></dt><dd><p>if the device is set to ‘/mpl’ (matplotlib), then pressing the
space bar will initiate a profile fit at the position of the cursor.
This defines the profile fitting method, either a gaussian or a
moffat profile. The latter is usually best.</p>
</dd>
<dt>beta<span class="classifier">float [method == ‘m’; hidden]</span></dt><dd><p>default Moffat exponent</p>
</dd>
<dt>fwhm<span class="classifier">float [hidden]</span></dt><dd><p>default FWHM, unbinned pixels. Do try to get this about right as
it affects whether the profile can be fitted at all.</p>
</dd>
<dt>fwhm_min<span class="classifier">float [hidden]</span></dt><dd><p>minimum FWHM to allow, unbinned pixels.</p>
</dd>
<dt>shbox<span class="classifier">float [hidden]</span></dt><dd><p>half width of box for searching for a star, unbinned
pixels. The above-threshold target closest to the centre of
the box in a region +/- shbox around an intial position
will be selected. It may not be the brightest, depending
upon your threshold settings, so use those to filter faint
objects. If profit=True, ‘shbox’ should be large enough to
allow for likely changes in position from frame to frame,
but not too large to avoid jumping to brighter targets or
possibly cosmic rays.</p>
</dd>
<dt>smooth<span class="classifier">float [hidden]</span></dt><dd><p>FWHM for gaussian smoothing, binned pixels. The initial position
for fitting is determined by finding the maximum flux in a smoothed
version of the image in a box of width +/- shbox around the starter
position. Typically should be comparable to the stellar width. Its
main purpose is to combat cosmic rays which tend only to occupy a
single pixel.</p>
</dd>
<dt>fhbox<span class="classifier">float [hidden]</span></dt><dd><p>half width of box for profile fit, unbinned pixels. The fit box is
centred on the position located by the initial search. It should
normally be &gt; ~2x the expected FWHM, and usually smaller than shbox</p>
</dd>
<dt>hmin<span class="classifier">float [hidden]</span></dt><dd><p>height threshold to accept a fit. If the height is below this
value, the position will not be updated. This is to help in cloudy
conditions. The limit is applied to the image after it has been
smoothed to make less vulnerable to seeing fluctuations. This
can mean it can be quite small.</p>
</dd>
<dt>read<span class="classifier">float [hidden]</span></dt><dd><p>readout noise, RMS ADU, for assigning uncertainties. Set to a -ve
value to try to ascertain on the fly; this is advisable either if
you don’t have a bias or you apply ‘msub’, and it will default to
this if not specified in this case. The value returned in this case
includes sky noise, i.e it should be roughly sqrt(R**2+S/G) where
R is the true read noise, S are the sky counts per pixel, and G the
gain. If read is set -ve, two fits are carried out per target. The
second of these should usually be pretty fast. The first is carried
out with an assumed large read noise of 20 in order to soften the
weights. The results reported apply to the second fit.</p>
</dd>
<dt>gain<span class="classifier">float [hidden]</span></dt><dd><p>gain, ADU/count, for assigning uncertainties.</p>
</dd>
<dt>thresh<span class="classifier">float [hidden]</span></dt><dd><p>sigma rejection threshold for fits</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.hpackage">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">hpackage</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.hpackage" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">hpackage</span> <span class="pre">runs</span> <span class="pre">dname</span> <span class="pre">tar</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">hpackage</span></code> looks for standard reduce data products and bundles
them up into a single directory and optionally creates a tar
file. The idea is to copy all the files needed to be able to
re-run the reduction with the pipeline, while also adding a few
helpful extras where possible. This is to make export of a reduction
relatively painless.</p>
<p>Given ‘run123’ for instance, it looks for:</p>
<blockquote>
<div><dl class="simple">
<dt>run123.hcm – typically the result from a run of <a class="reference internal" href="#hipercam.scripts.averun" title="hipercam.scripts.averun"><code class="xref py py-func docutils literal notranslate"><span class="pre">averun</span></code></a>. This <em>must</em></dt><dd><p>exist for each run included.</p>
</dd>
</dl>
<p>run123.ape – file of photometric apertures. Also must exist.</p>
<p>run123*.red – reduce file as made by <a class="reference internal" href="#hipercam.scripts.genred" title="hipercam.scripts.genred"><code class="xref py py-func docutils literal notranslate"><span class="pre">genred</span></code></a> (* == any string)</p>
<p>run123*.log – result from <a class="reference internal" href="#hipercam.scripts.reduce" title="hipercam.scripts.reduce"><code class="xref py py-func docutils literal notranslate"><span class="pre">reduce</span></code></a> (* == any string)</p>
</div></blockquote>
<p>Note the ‘*’ means that multiple .red / .log pairs are possible to
allow for multiple alternative reductions. But they must start
‘run123’ and end ‘.red’ and ‘.log’ to be included. There has to be
at least one such pair. It also looks for calibration files inside
the reduce file and copies them. It requires them to be within the
same directory and will fail if they are not. The reason for this
is that they get copied over to the same directory and the
directory structure required to store them elsewhere is not
created. I often use soft-links to point to calibration files for
this reason.</p>
<p>It produces several extra files which are:</p>
<blockquote>
<div><p>run123.fits – FITS version of the log file</p>
<dl class="simple">
<dt>run123_ccd1.fits – joined-up ds9-able version of run123.hcm</dt><dd><p>(and ccd2 etc) [but only if the windows are
in sync.</p>
</dd>
<dt>run123_ccd1.reg – ds9-region file representing the apertures</dt><dd><p>from run123.ape [see above re synced windows]</p>
</dd>
</dl>
<p>README – a file of explanation.</p>
</div></blockquote>
<p>The files are all copied to a temporary directory.</p>
<p>Arguments:</p>
<blockquote>
<div><dl class="simple">
<dt>run<span class="classifier">str</span></dt><dd><p>Series of run names of the ones to copy, separated by spaces.</p>
</dd>
<dt>dname<span class="classifier">str</span></dt><dd><p>Name for the directory to store all files forming the root of
any output tar file created from it.</p>
</dd>
<dt>tar<span class="classifier">bool</span></dt><dd><p>Make a tar.gz file of the directory at the end; the directory and
the files in it will be deleted. Otherwise, no tar file is made and
the directory is left untouched. The directory will however be deleted
if the program is aborted early.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.joinup">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">joinup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.joinup" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">joinup</span> <span class="pre">[source]</span> <span class="pre">(run</span> <span class="pre">first</span> <span class="pre">[twait</span> <span class="pre">tmax]</span> <span class="pre">|</span> <span class="pre">flist)</span> <span class="pre">trim</span> <span class="pre">([ncol</span>
<span class="pre">nrow])</span> <span class="pre">(ccd)</span> <span class="pre">(aper)</span> <span class="pre">bias</span> <span class="pre">dark</span> <span class="pre">flat</span> <span class="pre">fmap</span> <span class="pre">(fpair</span> <span class="pre">nhalf</span> <span class="pre">rmin</span> <span class="pre">rmax)</span>
<span class="pre">msub</span> <span class="pre">(ndigit)</span> <span class="pre">dtype</span> <span class="pre">dmax</span> <span class="pre">nmax</span> <span class="pre">[overwrite]</span> <span class="pre">compress</span> <span class="pre">odir</span></code></p>
<p>Converts a run or a list of hcm images into as near as possible
“standard” FITS files with one image in the primary HDU per file,
representing a single CCD with all windows merged. The aim above
all is to have a file that plays nicely with ‘ds9’. A file such as
‘run0002.fits’ (HiPERCAM) will end up producing files with names
like run0002_0001_ccd1.fits, run0002_001_ccd2.fits, etc and the
same for any of the other CCDs for frame 1, then
run0002_0002_ccd1.fits. ‘_ccd1’ etc will be tacked onto the names
from a list of files. The generated files will be written to the
present working directory. If the windows have gaps, then they
will be filled with zeroes.</p>
<p>When binning has been used it is possible for sub-windows to be
out of sync with each other so they cannot be simply added into a
single image. In this case the routine will instead place them
within an “unbinned” image with each binned pixel repeated within
this image xbin by ybin times. This and the zero filling can mean
that the resulting images are much larger than the
originals. There are safety parameters to guard against disaster
in such cases.</p>
<p><cite>joinup</cite> gives you the option of creating ds9 “region” files
corresponding to a HiPERCAM aperture file. These can be used in
a command such as:</p>
<div class="highlight-rest notranslate"><div class="highlight"><pre><span></span>ds9 run123_ccd2.fits -regions run123_ccd2.reg -zscale
</pre></div>
</div>
<p>or loaded from within ds9 instead.</p>
<p>Parameters:</p>
<blockquote>
<div><dl>
<dt>source<span class="classifier">str [hidden]</span></dt><dd><p>Data source, five options:</p>
<blockquote>
<div><div class="line-block">
<div class="line">‘hs’ : HiPERCAM server</div>
<div class="line">‘hl’ : local HiPERCAM FITS file</div>
<div class="line">‘us’ : ULTRACAM server</div>
<div class="line">‘ul’ : local ULTRACAM .xml/.dat files</div>
<div class="line">‘hf’ : list of HiPERCAM hcm FITS-format files</div>
</div>
</div></blockquote>
<p>‘hf’ is used to look at sets of frames generated by ‘grab’
or converted from foreign data formats. The standard
start-off default for <code class="docutils literal notranslate"><span class="pre">source</span></code> can be set using the
environment variable HIPERCAM_DEFAULT_SOURCE. e.g. in bash
<code class="code docutils literal notranslate"><span class="pre">export</span> <span class="pre">HIPERCAM_DEFAULT_SOURCE=&quot;us&quot;</span></code> would ensure it
always started with the ULTRACAM server by default. If
unspecified, it defaults to ‘hl’.</p>
</dd>
<dt>run<span class="classifier">string [if source ends ‘s’ or ‘l’]</span></dt><dd><p>run number to access, e.g. ‘run034’</p>
</dd>
<dt>first<span class="classifier">int [if source ends ‘s’ or ‘l’]</span></dt><dd><p>exposure number to start from. 1 = first frame. For data
from the HiPERCAM server, a negative number tries to get a frame not
quite at the end.  i.e. -10 will try to get 10 from the last
frame. This is mainly to sidestep a difficult bug with the
acquisition system.</p>
</dd>
<dt>last<span class="classifier">int [if source ends ‘s’ or ‘l’]</span></dt><dd><p>Last frame to access, 0 for the lot</p>
</dd>
<dt>twait<span class="classifier">float [if source ends ‘s’ or ‘l’; hidden]</span></dt><dd><p>time to wait between attempts to find a new exposure, seconds.</p>
</dd>
<dt>tmax<span class="classifier">float [if source ends ‘s’ or ‘l’; hidden]</span></dt><dd><p>maximum time to wait between attempts to find a new exposure,
seconds.</p>
</dd>
<dt>flist<span class="classifier">str [if source ends ‘f’]</span></dt><dd><p>name of file list or just a single hcm file</p>
</dd>
<dt>trim<span class="classifier">bool [if source starts with ‘u’]</span></dt><dd><p>True to trim columns and/or rows off the edges of windows nearest
the readout which can sometimes contain bad data.</p>
</dd>
<dt>ncol<span class="classifier">int [if trim, hidden]</span></dt><dd><p>Number of columns to remove (on left of left-hand window, and right
of right-hand windows)</p>
</dd>
<dt>nrow<span class="classifier">int [if trim, hidden]</span></dt><dd><p>Number of rows to remove (bottom of windows)</p>
</dd>
<dt>ccd<span class="classifier">string</span></dt><dd><p>CCD(s) to plot, ‘0’ for all, ‘1 3’ to plot ‘1’ and ‘3’ only, etc.</p>
</dd>
<dt>aper<span class="classifier">str [if source ends ‘s’ or ‘l’ or just a single file]</span></dt><dd><p>A photometric aperture file associated with the run or images.
This will be translated into a file of “regions” (extension .reg)
for each CCD they are defined for. The file can be loaded into
ds9 showing the apertures over the image.</p>
</dd>
<dt>bias<span class="classifier">str</span></dt><dd><p>Name of bias frame to subtract, ‘none’ to ignore.</p>
</dd>
<dt>dark<span class="classifier">str</span></dt><dd><p>Name of dark frame to correct for dark counts. ‘none’ to
ignore.</p>
</dd>
<dt>flat<span class="classifier">str</span></dt><dd><p>Name of flat field to divide by, ‘none’ to ignore. Should normally
only be used in conjunction with a bias, although it does allow you
to specify a flat even if you haven’t specified a bias.</p>
</dd>
<dt>fmap<span class="classifier">str</span></dt><dd><p>Fringe map to remove fringes, ‘none’ to ignore.</p>
</dd>
<dt>fpair<span class="classifier">str [if fmap is not == ‘none’]</span></dt><dd><p>File of peak/trough pairs for fringe amplitude measurement.</p>
</dd>
<dt>nhalf<span class="classifier">int [if fmap is not == ‘none’, hidden]</span></dt><dd><p>Half-size of regions around each point for measuring intensity
differences from peak/trough pairs.</p>
</dd>
<dt>rmin<span class="classifier">float [if fmap is not == ‘none’, hidden]</span></dt><dd><p>Minimum individual ratio for pruning peak/tough ratios prior to
taking their median.</p>
</dd>
<dt>rmin<span class="classifier">float [if fmap is not == ‘none’, hidden]</span></dt><dd><p>Maximum individual ratio for pruning peak/trough ratios prior to
taking their median.</p>
</dd>
<dt>msub<span class="classifier">bool</span></dt><dd><p>subtract the median from each window. If set this happens after any
bias subtraction etc.</p>
</dd>
<dt>ndigit<span class="classifier">int [if source ends ‘s’ or ‘l’]</span></dt><dd><p>number of digits to be used in the frame counter attached
to the output file names. These are zero-padded so that the
frames order alphabetically. Thus ‘run0002_ccd1_0001.fits’,
‘run0002_ccd1_0002.fits’, ‘run0002_ccd1_0003.fits’ … for
instance.</p>
</dd>
<dt>dtype<span class="classifier">str</span></dt><dd><p>output data type. ‘unit16’, ‘float32’, ‘float64’. The first
of these (2-byte unsigned) is only probably a good idea if
no bias, flat field or median subtraction has been applied
because it involves rounding and it will fail if any data
are out of the range 0 to 65535. 32-bit (4 byte) floats
should be OK for most purposes, but require twice the space
of uint16.</p>
</dd>
<dt>dmax<span class="classifier">float</span></dt><dd><p>Maximum amount of data in GB to write out. A safety device
to avoid disaster in case this script was applied to highly
windowed data where you can end up expanding the total
amount of data by a large factor.</p>
</dd>
<dt>nmax<span class="classifier">int</span></dt><dd><p>Maximum number of frames. A similar safety device to dmax
to avoid inadvertent application of this script to a
million+ frame run. File systems tend not to behave well
with vast numbers of files.</p>
</dd>
<dt>overwrite<span class="classifier">bool [hidden]</span></dt><dd><p>overwrite any pre-existing files. Defaults to ‘False’
for safety.</p>
</dd>
<dt>compress<span class="classifier">str</span></dt><dd><p>allows data to be compressed with FITS’s internal lossless
compression mechanisms. The file will still end as “.fits”
but has a different internal format; ‘ds9’ copes seamlessly
with all of them. The options are: ‘none’, ‘rice’, ‘gzip1’,
‘gzip2’. ‘rice’ gave about a factor of 2 compression in a
short test I ran, and was as fast as gzip2, but it may
depend upon the nature of the data. ‘none’ is fastest. See
astropy.io.fits for further documentation.</p>
</dd>
<dt>odir<span class="classifier">str</span></dt><dd><p>directory for output files. This routine can produce many
files so it often makes sense to direct them to a specific
directory. ‘.’ for the PWD. [Must exist prior to running
the script.]</p>
</dd>
</dl>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Be careful of running this on highly windowed data since it
could end up expanding the total amount of “data” hugely.  It’s
really aimed at full frame runs above all. The “dmax” and
“nmax” parameters are aimed at heading off disaster.</p>
<p>The routine only creates a window big enough to contain all the
windows. Thus it might end up representing a sub-array of the
CCD as opposed to all of it. The location can be determined
from the ‘LLX’ and ‘LLY’ parameters that are written to the
header. These represent the location of the lowest and leftmost
unbinned pixel that is contained within the data array. The
bottom-left pixel of the CCD is considered to be (1,1), so full
frame images have LLX=LLY=1.</p>
<p>A HipercamError will be raised if an attempt is made to write out
data outside the range 0 to 65535 into unit16 format and nothing
will be written.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.ltimes">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">ltimes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.ltimes" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">ltimes</span> <span class="pre">[source]</span> <span class="pre">run</span> <span class="pre">first</span> <span class="pre">last</span> <span class="pre">[twait</span> <span class="pre">tmax</span> <span class="pre">tdigit</span> <span class="pre">edigit]</span></code></p>
<p>Lists timing information from a run in machine-readable space-separated
column style. Integer status flags are used, 1=OK, 0=not OK.</p>
<p>For HiPERCAM, the following items are listed: (1) the frame
number, (2) the raw GPS timestamp as an MJD, (3) the raw GPS
timestamp as a UTC string, (4) a status flag, 0 or 1, then for
each CCD: (i) the CCD number [1-5], (ii) the mid exposure time as
an MJD, (iii) the mid-exposure time as a UTC string, (iv) the
exposure length (seconds), (v) a status flag (0 or 1), determined
by the NSKIP parameters for each CCD.</p>
<p>For ULTRACAM, the following items are listed: (1) the frame
number, (2) the raw GPS timestamp as an MJD, (3) the raw GPS
timestamp as a UTC string, (4) the red &amp; green mid exposure time
as an MJD, (5) the red &amp; green mid-exposure time as a UTC string,
(6) a status flag to indicate whether the mid-exposure time is
considered to be good, (7) the exposure time in seconds, (8) the
blue mid-exposure time as an MJD, (9) the blue mid-exposure time
as a UTC string, (10) status flag of the blue data, which reflects
the “nblue” option where only some of the blue frames are valid
data.</p>
<p>For ULTRASPEC, the following items are listed: (1) the frame
number, (2) the raw GPS timestamp as an MJD, (3) the raw GPS
timestamp as a UTC string, (4) the mid-exposure time as an MJD,
(5) the mid-exposure time as a UTC string, (6) a status flag to
indicate whether the mid-exposure time is considered to be good,
(7) the exposure time in seconds.</p>
<p>Parameters:</p>
<blockquote>
<div><dl>
<dt>source<span class="classifier">string [hidden]</span></dt><dd><p>Data source, two options:</p>
<blockquote>
<div><div class="line-block">
<div class="line">‘hs’ : HiPERCAM server</div>
<div class="line">‘hl’ : local HiPERCAM FITS file</div>
<div class="line">‘us’ : local ULTRA(CAM|SPEC) file</div>
<div class="line">‘ul’ : ULTRA(CAM|SPEC) server</div>
</div>
</div></blockquote>
</dd>
<dt>run<span class="classifier">string</span></dt><dd><p>run number to access, e.g. ‘run0034’</p>
</dd>
<dt>first<span class="classifier">int</span></dt><dd><p>exposure number to start from. 1 = first frame; set = 0 to
always try to get the most recent frame (if it changes)</p>
</dd>
<dt>last<span class="classifier">int</span></dt><dd><p>last exposure number, 0 for all.</p>
</dd>
<dt>twait<span class="classifier">float [hidden]</span></dt><dd><p>time to wait between attempts to find a new exposure, seconds.</p>
</dd>
<dt>tmax<span class="classifier">float [hidden]</span></dt><dd><p>maximum time to wait between attempts to find a new exposure,
seconds. Set to 0 to avoid waiting and extra output messages.</p>
</dd>
<dt>tdigit<span class="classifier">int [hidden]</span></dt><dd><p>number of digits of precision for the seconds after the decimal
point when reporting the times.</p>
</dd>
<dt>edigit<span class="classifier">int [hidden]</span></dt><dd><p>number of digits of precision after the decimal point when
reporting the exposure times</p>
</dd>
</dl>
</div></blockquote>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This routine does not yet work with ULTRACAM data.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.ltrans">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">ltrans</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.ltrans" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">ltrans</span> <span class="pre">posns</span></code></p>
<p>Reads a file of target positions dumped by <cite>ftargets</cite> and uses it
to derive the transformations needed to co-align images.</p>
<p>Parameters:</p>
<blockquote>
<div><dl class="simple">
<dt>posns<span class="classifier">string</span></dt><dd><p>file of positions generated by <cite>ftargets</cite></p>
</dd>
<dt>cmax<span class="classifier">float</span></dt><dd><p>maximum number of counts at peak allowed for a target. Targets
with greater than this will be ignored when computing the transform.</p>
</dd>
<dt>emax<span class="classifier">float</span></dt><dd><p>maximum ratio a/b, major/minor axis elongation. Targets more elongated
than this will be ignored.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.makebias">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">makebias</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.makebias" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">makebias</span> <span class="pre">[source]</span> <span class="pre">run</span> <span class="pre">first</span> <span class="pre">last</span> <span class="pre">twait</span> <span class="pre">tmax</span> <span class="pre">sigma</span> <span class="pre">plot</span>
<span class="pre">output</span></code></p>
<p>Combines the frames of a single run (or list) into a single frame
using clipped-mean averaging appropriate for biases. This uses
<code class="docutils literal notranslate"><span class="pre">grab</span></code> to get the frames and <code class="docutils literal notranslate"><span class="pre">combine</span></code> to combine them. If you
already have the frames separately, then just use <code class="docutils literal notranslate"><span class="pre">combine</span></code>
directly.</p>
<p>Parameters:</p>
<blockquote>
<div><blockquote>
<div><dl>
<dt>source<span class="classifier">str [hidden]</span></dt><dd><p>Data source, four options:</p>
<blockquote>
<div><div class="line-block">
<div class="line">‘hs’ : HiPERCAM server</div>
<div class="line">‘hl’ : local HiPERCAM FITS file</div>
<div class="line">‘us’ : ULTRACAM server</div>
<div class="line">‘ul’ : local ULTRACAM .xml/.dat files</div>
<div class="line">‘hf’ : list of HiPERCAM hcm FITS-format files</div>
</div>
</div></blockquote>
<p>‘hf’ is used to look at sets of frames generated by ‘grab’
or converted from foreign data formats. The standard
start-off default for <code class="docutils literal notranslate"><span class="pre">source</span></code> can be set using the
environment variable HIPERCAM_DEFAULT_SOURCE. e.g. in bash
<code class="code docutils literal notranslate"><span class="pre">export</span> <span class="pre">HIPERCAM_DEFAULT_SOURCE=&quot;us&quot;</span></code> would ensure it
always started with the ULTRACAM server by default. If
unspecified, it defaults to ‘hl’.</p>
</dd>
<dt>run<span class="classifier">str</span></dt><dd><p>run name to access</p>
</dd>
<dt>first<span class="classifier">int</span></dt><dd><p>First frame to access</p>
</dd>
<dt>last<span class="classifier">int</span></dt><dd><p>Last frame to access, 0 for the lot</p>
</dd>
<dt>twait<span class="classifier">float [hidden]</span></dt><dd><p>time to wait between attempts to find a new exposure, seconds.</p>
</dd>
<dt>tmax<span class="classifier">float [hidden]</span></dt><dd><blockquote>
<div><p>maximum time to wait between attempts to find a new exposure,
seconds.</p>
</div></blockquote>
<dl class="simple">
<dt>flist<span class="classifier">str [if source ends ‘f’]</span></dt><dd><p>name of file list.</p>
</dd>
<dt>sigma<span class="classifier">float</span></dt><dd><p>The value of ‘sigma’ to pass to the clipped mean combination in
‘combine’</p>
</dd>
</dl>
</dd>
<dt>plot<span class="classifier">bool</span></dt><dd><p>make a plot of the mean level versus frame number for each
CCD. This can provide a quick check that the frames are not too
different. You will need explicitly to close the plot generated at
the end of the script</p>
</dd>
<dt>output<span class="classifier">str</span></dt><dd><p>name of final combined file. Set by default to match the
last part of “run” (but it will have a different extension
so they won’t clash)</p>
</dd>
</dl>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This routine writes the files returned by ‘grab’ to
automatically generated files, typically in .hipercam/tmp, to
avoid polluting the working directory. These are removed at
the end, but may not be if you ctrl-C. You should check
.hipercam/tmp for redundant files every so often</p>
</div>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.makedark">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">makedark</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.makedark" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">makedark</span> <span class="pre">[source]</span> <span class="pre">(run</span> <span class="pre">first</span> <span class="pre">last</span> <span class="pre">[twait</span> <span class="pre">tmax]</span> <span class="pre">|</span> <span class="pre">flist)</span> <span class="pre">bias</span>
<span class="pre">sigma</span> <span class="pre">output</span></code></p>
<p>Combines the frames of a single run into a single frame using clipped-mean
averaging. This uses <code class="docutils literal notranslate"><span class="pre">grab</span></code> to get the frames and <code class="docutils literal notranslate"><span class="pre">combine</span></code> to combine
them. It subtracts a bias and corrects the exposure time by the exposure
time of the bias.</p>
<p>Parameters:</p>
<blockquote>
<div><blockquote>
<div><dl>
<dt>source<span class="classifier">string [hidden]</span></dt><dd><p>Data source, four options:</p>
<blockquote>
<div><div class="line-block">
<div class="line">‘hs’ : HiPERCAM server</div>
<div class="line">‘hl’ : local HiPERCAM FITS file</div>
<div class="line">‘us’ : ULTRACAM server</div>
<div class="line">‘ul’ : local ULTRACAM .xml/.dat files</div>
<div class="line">‘hf’ : list of HiPERCAM hcm FITS-format files</div>
</div>
</div></blockquote>
<p>The standard start-off default for <code class="docutils literal notranslate"><span class="pre">source</span></code> can be set
using the environment variable
HIPERCAM_DEFAULT_SOURCE. e.g. in bash <code class="code docutils literal notranslate"><span class="pre">export</span>
<span class="pre">HIPERCAM_DEFAULT_SOURCE=&quot;us&quot;</span></code> would ensure it always
started with the ULTRACAM server by default. If
unspecified, it defaults to ‘hl’.</p>
</dd>
<dt>run<span class="classifier">str [if source ends ‘s’ or ‘l’]</span></dt><dd><p>run name to access</p>
</dd>
<dt>first<span class="classifier">int [if source ends ‘s’ or ‘l’]</span></dt><dd><p>First frame to access</p>
</dd>
<dt>last<span class="classifier">int [if source ends ‘s’ or ‘l’]</span></dt><dd><p>Last frame to access, 0 for the lot</p>
</dd>
<dt>twait<span class="classifier">float [[if source ends ‘s’ or ‘l’, hidden]</span></dt><dd><p>time to wait between attempts to find a new exposure, seconds.</p>
</dd>
<dt>tmax<span class="classifier">float [[if source ends ‘s’ or ‘l’, hidden]</span></dt><dd><p>maximum time to wait between attempts to find a new exposure,
seconds.</p>
</dd>
<dt>flist<span class="classifier">str [if source ends ‘f’]</span></dt><dd><p>name of file list. Assumed that these are dias and dark corrected.</p>
</dd>
<dt>bias<span class="classifier">str</span></dt><dd><p>Names of bias frame (made e.g. with <a class="reference internal" href="#hipercam.scripts.makebias" title="hipercam.scripts.makebias"><code class="xref py py-func docutils literal notranslate"><span class="pre">makebias</span></code></a>). This is
so that the counts left in the dark frame are genuine dark
counts which can be scaled by the ratio of exposure lengths
during dark subtraction.</p>
</dd>
<dt>sigma<span class="classifier">float</span></dt><dd><p>The value of ‘sigma’ to pass to the clipped mean combination in
‘combine’</p>
</dd>
<dt>output<span class="classifier">str</span></dt><dd><p>name of final combined file</p>
</dd>
</dl>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This routine writes the files returned by ‘grab’ to
automatically generated files, typically in .hipercam/tmp, to
avoid polluting the working directory. These are removed at
the end, but may not be if you ctrl-C. You should check
.hipercam/tmp for redundant files every so often</p>
</div>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.makeflat">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">makeflat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.makeflat" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">makeflat</span> <span class="pre">[source]</span> <span class="pre">(run</span> <span class="pre">first</span> <span class="pre">last</span> <span class="pre">[twait</span> <span class="pre">tmax]</span> <span class="pre">|</span> <span class="pre">flist)</span>
<span class="pre">bias</span> <span class="pre">dark</span> <span class="pre">ngroup</span> <span class="pre">ccd</span> <span class="pre">lower</span> <span class="pre">upper</span> <span class="pre">[clobber]</span> <span class="pre">output</span></code></p>
<p>Averages a set of images to make a flat field.</p>
<p>Typically flat-fields for HiPERCAM and ULTRA(CAM|SPEC) are taken with a
strongly time-variable twilight sky as the Sun sets or rises. A typical
flat field run may start out bright, or even saturated, but by the end be
only a few thousand counts above bias. Moreover, there are very often
stars visible in the images, so we usually take them while offsetting the
telescope in a spiral pattern. The challenge is to combine these images
while rejecting the stars and saturated frames and giving due weight to
the better exposed images. This moreover has to be done for each CCD which
vary significantly in sensitivity.</p>
<p>‘makeflat’ does this as follows: given an input list of files (or
optionally a single run), it reads them all in, debiases them
(optionally), and calculates the mean count level in each CCD,
normalises by the mean and writes out the results to temporary
files. For each CCD it then sorts the files by their (original)
mean level, and for those that lie between defined limits it takes
the median of the mean-normalised frames in groups of defined
size. Thus, say one had 75 OK images, then these would be divided
into 10 groups, the first 9 having 7 frames, the last having
12. The median average of each of these would be taken. In each
case the mean levels would be adjusted to be the same before
taking the average to overcome the problem of taking a median of a
time-variable sky. The assumption is that while the level may
vary, the pattern of the image does not. It is up to the user to
check that this is correct. Each of the medians is adjusted to
have a mean equal to the sum of the means of the input
frames. Finally the normal average of all of these median frames
is taken and the mean level of the final output normalised to
1. The first step, taking the median in groups is designed to
remove the stars assuming that the telescope was spiralled. The
size of the groups (‘ngroup’ below is a crucial parameter in
whether this works). A good strategy is to run makeflat for a
succession of ever larger ‘ngroup’ and then to divide the results
into each other to see if stars are visible.</p>
<p>The final step, the average of the medians with adjusted mean
levels, is to ensure that the flats are combined in a way that
reflects the level of signal that they have, i.e. to avoid giving
equal weights to the median of a series of flats with 20,000 counts
per pixel and another series with 1,000 counts per pixel. This
somewhat complex procedure is implemented through a series of
temporary files which are written and read as the script runs, but
deleted at its end. This allows very large numbers to be combined
as long as there is enough memory to load ‘ngroup’ CCDs
simultaneously, which should usually be fine.</p>
<p>Parameters:</p>
<blockquote>
<div><blockquote>
<div><dl>
<dt>source<span class="classifier">str [hidden]</span></dt><dd><p>Data source, five options:</p>
<blockquote>
<div><div class="line-block">
<div class="line">‘hs’ : HiPERCAM server</div>
<div class="line">‘hl’ : local HiPERCAM FITS file</div>
<div class="line">‘us’ : ULTRACAM server</div>
<div class="line">‘ul’ : local ULTRACAM .xml/.dat files</div>
<div class="line">‘hf’ : list of HiPERCAM hcm FITS-format files</div>
</div>
</div></blockquote>
<p>‘hf’ is used to look at sets of frames generated by ‘grab’
or converted from foreign data formats. The standard
start-off default for <code class="docutils literal notranslate"><span class="pre">source</span></code> can be set using the
environment variable HIPERCAM_DEFAULT_SOURCE. e.g. in bash
<code class="code docutils literal notranslate"><span class="pre">export</span> <span class="pre">HIPERCAM_DEFAULT_SOURCE=&quot;us&quot;</span></code> would ensure it
always started with the ULTRACAM server by default. If
unspecified, it defaults to ‘hl’.</p>
</dd>
<dt>run<span class="classifier">str [if source ends ‘s’ or ‘l’]</span></dt><dd><p>run number to access, e.g. ‘run034’</p>
</dd>
<dt>first<span class="classifier">int [if source ends ‘s’ or ‘l’]</span></dt><dd><p>exposure number to start from. 1 = first frame (‘0’ is
not supported).</p>
</dd>
<dt>last<span class="classifier">int [if source ends ‘s’ or ‘l’]</span></dt><dd><p>last exposure number must be &gt;= first or 0 for the whole lot.</p>
</dd>
<dt>twait<span class="classifier">float [if source ends ‘s’ or ‘l’; hidden]</span></dt><dd><p>time to wait between attempts to find a new exposure, seconds.</p>
</dd>
<dt>tmax<span class="classifier">float [if source ends ‘s’ or ‘l’; hidden]</span></dt><dd><p>maximum time to wait between attempts to find a new exposure,
seconds.</p>
</dd>
<dt>flist<span class="classifier">str [if source ends ‘f’]</span></dt><dd><p>name of file list. Assumed that these are dias and dark corrected.</p>
</dd>
<dt>bias<span class="classifier">str</span></dt><dd><p>Name of bias frame to subtract, ‘none’ to ignore.</p>
</dd>
<dt>dark<span class="classifier">str</span></dt><dd><p>Name of dark frame to subtract, ‘none’ to ignore. Note that
it is assumed all CCDs have the same exposure time when making
a dark correction.</p>
</dd>
<dt>ngroup<span class="classifier">int</span></dt><dd><p>the number of frames. Probably should be at least 5, preferably
more. Experiment to see its effect.</p>
</dd>
<dt>ccd<span class="classifier">str</span></dt><dd><p>CCD(s) to process, ‘0’ for all, ‘1 3’ for ‘1’ and ‘3’ only, etc.
Would almost always expect this to be set = ‘0’.</p>
</dd>
<dt>lower<span class="classifier">list of floats</span></dt><dd><p>Lower limits to the mean count level for a flat to be included. The
count level is determined after bias subtraction.  Should be the
same number as the selected CCDs, and will be assumed to be in the
same order. Use this to elminate frames that are of so low a level
that the accuracy of the bias subtraction could be a worry.
Suggested hipercam values: 3000 for each CCD. Enter values separated
by spaces.</p>
</dd>
<dt>upper<span class="classifier">list of floats</span></dt><dd><p>Upper limits to the mean count level for a flat to be included. The
count level is determined <em>after</em> bias subtraction.  Should be the
same number as the selected CCDs, and will be assumed to be in the
same order. Use this to eliminate saturated, peppered or non-linear
frames. Suggested hipercam values: 58000, 58000, 58000, 40000 and
40000 for CCDs 1, 2, 3, 4 and 5. Enter values separated by spaces.
ULTRACAM values 49000, 29000, 27000 for CCDs 1, 2 and 3.</p>
</dd>
<dt>clobber<span class="classifier">bool [hidden]</span></dt><dd><p>clobber any pre-existing output files</p>
</dd>
<dt>output<span class="classifier">str</span></dt><dd><p>output file. will be set by default to match the input name.</p>
</dd>
</dl>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This routine writes the files returned by ‘grab’ to
automatically generated files, typically in .hipercam/tmp, to
avoid polluting the working directory. These are removed at
the end, but may not be if you ctrl-C. You should check
.hipercam/tmp for redundant files every so often</p>
</div>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.makefringe">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">makefringe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.makefringe" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">makefringe</span> <span class="pre">[source]</span> <span class="pre">(run</span> <span class="pre">first</span> <span class="pre">last</span> <span class="pre">[twait</span> <span class="pre">tmax]</span> <span class="pre">|</span> <span class="pre">flist)</span> <span class="pre">bias</span>
<span class="pre">dark</span> <span class="pre">flat</span> <span class="pre">fpair</span> <span class="pre">([nhalf])</span> <span class="pre">ccd</span> <span class="pre">fwhm</span> <span class="pre">[clobber]</span> <span class="pre">output</span></code></p>
<p>Averages a set of images to make a frame for defringing (referred
to elsewhere as a “fringe map”).</p>
<p>At long wavelengths, CCDs suffer what is known as “fringing”,
which in terms of structure looks something like the coloured
patterns you see when there is a thin layer of oil on water. Both
patterns are caused by interference.  In the case of CCDs this is
caused by sky emission lines and is variable in strength, and
additive in nature, but seems mostly fairly fixed in position.</p>
<p>De-fringing in HiPERCAM is implemented according to the method
suggested by Snodgrass &amp; Carry (2013Msngr.152…14S). The idea is
to create a set of pairs of points marking the peak and troughs of
fringes. The differences in intensity between these point pairs in
the data to be corrected is compared with the differences for the
same pairs in a reference “fringe map” by taking their
ratios. Many pairs are used so that the median can be taken to
eliminate ratios affected by celestial targets or cosmic rays. The
median ratio is used to scale the reference data and thereby
subtract the fringes. <code class="docutils literal notranslate"><span class="pre">makefringe</span></code> is used to make the reference
fringe map. It works as follows: given a single run or a list of
files, it reads them all in, optionally debiases, dark-subtracts
and flat-fields them, calculates a median count level of each one
which is subtracted from each CCD individually. The pixel-by-pixel
median of all frames is then calculated. It is also possible (and
a good idea) to apply the fringe pair ratio measurements to scale
each frame before combining them, which allows frames of similar
pattern but varying amplitude to be combined. Finally, the output
can be smoothed because fringes are usually a medium- to
large-scale pattern.</p>
<p>Parameters:</p>
<blockquote>
<div><blockquote>
<div><dl>
<dt>source<span class="classifier">string [hidden]</span></dt><dd><p>Data source, five options:</p>
<blockquote>
<div><div class="line-block">
<div class="line">‘hs’ : HiPERCAM server</div>
<div class="line">‘hl’ : local HiPERCAM FITS file</div>
<div class="line">‘us’ : ULTRACAM server</div>
<div class="line">‘ul’ : local ULTRACAM .xml/.dat files</div>
<div class="line">‘hf’ : list of HiPERCAM hcm FITS-format files</div>
</div>
</div></blockquote>
<p>‘hf’ is used to look at sets of frames generated by ‘grab’ or
converted from foreign data formats.</p>
</dd>
<dt>run<span class="classifier">string [if source ends ‘s’ or ‘l’]</span></dt><dd><p>run number to access, e.g. ‘run034’</p>
</dd>
<dt>first<span class="classifier">int [if source ends ‘s’ or ‘l’]</span></dt><dd><p>exposure number to start from. 1 = first frame (‘0’ is
not supported).</p>
</dd>
<dt>last<span class="classifier">int [if source ends ‘s’ or ‘l’]</span></dt><dd><p>last exposure number must be &gt;= first or 0 for the whole lot.</p>
</dd>
<dt>twait<span class="classifier">float [if source ends ‘s’ or ‘l’; hidden]</span></dt><dd><p>time to wait between attempts to find a new exposure, seconds.</p>
</dd>
<dt>tmax<span class="classifier">float [if source ends ‘s’ or ‘l’; hidden]</span></dt><dd><p>maximum time to wait between attempts to find a new exposure,
seconds.</p>
</dd>
<dt>flist<span class="classifier">string [if source ends ‘f’]</span></dt><dd><p>name of file list. Assumed that bias, flat-fielding etc have been applied to
these already.</p>
</dd>
<dt>bias<span class="classifier">str</span></dt><dd><p>Name of bias frame to subtract, ‘none’ to ignore.</p>
</dd>
<dt>dark<span class="classifier">str</span></dt><dd><p>Name of dark frame to subtract, ‘none’ to ignore.</p>
</dd>
<dt>flat<span class="classifier">str</span></dt><dd><p>Name of flat field, ‘none’ to ignore.</p>
</dd>
<dt>fpair<span class="classifier">str</span></dt><dd><p>FringePair file (see setfringe), or ‘none’ to ignore. If specified
if will be used to scale the frames prior to combining.</p>
</dd>
<dt>nhalf<span class="classifier">int [if fpair is not ‘none’]</span></dt><dd><p>When calculating the differences for fringe measurement,
a region extending +/-nhalf binned pixels will be used when
measuring the amplitudes. Basically helps the stats.</p>
</dd>
<dt>ccd<span class="classifier">str</span></dt><dd><p>CCD(s) to process, ‘0’ for all, ‘1 3’ for ‘1’ and ‘3’ only, etc.</p>
</dd>
<dt>fwhm<span class="classifier">float</span></dt><dd><p>FWHM (unbinned pixels) of gaussian smoothing to apply to the output.
0 to ignore. Should be &lt;&lt; smallest scale between fringes. Probably
no more than 4.</p>
</dd>
<dt>clobber<span class="classifier">bool [hidden]</span></dt><dd><p>clobber any pre-existing output files</p>
</dd>
<dt>output<span class="classifier">str</span></dt><dd><p>output file. Set by default to match the last part of “run”
(but it will have a different extension so they won’t
clash). The default is</p>
</dd>
</dl>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This routine writes the files returned by ‘grab’ to
automatically generated files, typically in .hipercam/tmp, to
avoid polluting the working directory. These are removed at
the end, but may not be if you ctrl-C. You should check
.hipercam/tmp for redundant files every so often</p>
</div>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.makemovie">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">makemovie</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.makemovie" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">makemovie</span> <span class="pre">[source]</span> <span class="pre">(run</span> <span class="pre">first</span> <span class="pre">last</span> <span class="pre">|</span> <span class="pre">flist)</span> <span class="pre">trim</span> <span class="pre">([ncol</span> <span class="pre">nrow])</span>
<span class="pre">(ccd</span> <span class="pre">(nx))</span> <span class="pre">bias</span> <span class="pre">flat</span> <span class="pre">defect</span> <span class="pre">log</span> <span class="pre">(targ</span> <span class="pre">comp</span> <span class="pre">ymin</span> <span class="pre">ymax</span> <span class="pre">yscales</span>
<span class="pre">yoffset</span> <span class="pre">location</span> <span class="pre">fraction</span> <span class="pre">lpad)</span> <span class="pre">cmap</span> <span class="pre">width</span> <span class="pre">height</span> <span class="pre">dstore</span> <span class="pre">ndigit</span> <span class="pre">fext</span> <span class="pre">msub</span> <span class="pre">iset</span>
<span class="pre">(ilo</span> <span class="pre">ihi</span> <span class="pre">|</span> <span class="pre">plo</span> <span class="pre">phi)</span> <span class="pre">xlo</span> <span class="pre">xhi</span> <span class="pre">ylo</span> <span class="pre">yhi</span> <span class="pre">[dpi</span> <span class="pre">(style</span> <span class="pre">(ms</span> <span class="pre">lw))]</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">makemovie</span></code> is for generating stills to combine into a movie for
presentations. It can optionally also read a log file from the run
to display an evolving light curve. There are lots of fiddly
parameters mostly to do with the plot positioning, so try it out
on a small number of frames first before going mad.</p>
<p>Parameters:</p>
<blockquote>
<div><dl>
<dt>source<span class="classifier">str [hidden]</span></dt><dd><p>Data source, five options:</p>
<blockquote>
<div><div class="line-block">
<div class="line">‘hs’ : HiPERCAM server</div>
<div class="line">‘hl’ : local HiPERCAM FITS file</div>
<div class="line">‘us’ : ULTRACAM server</div>
<div class="line">‘ul’ : local ULTRACAM .xml/.dat files</div>
<div class="line">‘hf’ : list of HiPERCAM hcm FITS-format files</div>
</div>
</div></blockquote>
<p>‘hf’ is used to look at sets of frames generated by ‘grab’
or converted from foreign data formats. The standard
start-off default for <code class="docutils literal notranslate"><span class="pre">source</span></code> can be set using the
environment variable HIPERCAM_DEFAULT_SOURCE. e.g. in bash
<code class="code docutils literal notranslate"><span class="pre">export</span> <span class="pre">HIPERCAM_DEFAULT_SOURCE=&quot;us&quot;</span></code> would ensure it
always started with the ULTRACAM server by default. If
unspecified, it defaults to ‘hl’.</p>
</dd>
<dt>run<span class="classifier">str [if source ends ‘s’ or ‘l’]</span></dt><dd><p>run number to access, e.g. ‘run034’</p>
</dd>
<dt>flist<span class="classifier">str [if source ends ‘f’]</span></dt><dd><p>name of file list</p>
</dd>
<dt>first<span class="classifier">int [if source ends ‘s’ or ‘l’]</span></dt><dd><p>exposure number to start from. 1 = first frame.</p>
</dd>
<dt>last<span class="classifier">int [if source ends ‘s’ or ‘l’]</span></dt><dd><p>last exposure</p>
</dd>
<dt>trim<span class="classifier">bool [if source starts with ‘u’]</span></dt><dd><p>True to trim columns and/or rows off the edges of windows nearest
the readout which can sometimes contain bad data.</p>
</dd>
<dt>ncol<span class="classifier">int [if trim, hidden]</span></dt><dd><p>Number of columns to remove (on left of left-hand window, and right
of right-hand windows)</p>
</dd>
<dt>nrow<span class="classifier">int [if trim, hidden]</span></dt><dd><p>Number of rows to remove (bottom of windows)</p>
</dd>
<dt>ccd<span class="classifier">str</span></dt><dd><p>CCD(s) to plot, ‘0’ for all, ‘1 3’ to plot ‘1’ and ‘3’ only, etc. If
you plot more than one, then a legend is added to any light curve panel
to distinguish the light curves.</p>
</dd>
<dt>nx<span class="classifier">int [if more than 1 CCD]</span></dt><dd><p>number of panels across to display for the image display.</p>
</dd>
<dt>bias<span class="classifier">str</span></dt><dd><p>Name of bias frame to subtract, ‘none’ to ignore.</p>
</dd>
<dt>dark<span class="classifier">str</span></dt><dd><p>Name of dark frame to subtract, ‘none’ to ignore.</p>
</dd>
<dt>flat<span class="classifier">str</span></dt><dd><p>Name of flat field to divide by, ‘none’ to ignore. Should normally
only be used in conjunction with a bias, although it does allow you
to specify a flat even if you haven’t specified a bias.</p>
</dd>
<dt>defect<span class="classifier">str</span></dt><dd><p>Name of defect file, ‘none’ to ignore.</p>
</dd>
<dt>fmap<span class="classifier">str</span></dt><dd><p>Name of fringe map (see e.g. <cite>makefringe</cite>), ‘none’ to ignore.</p>
</dd>
<dt>fpair<span class="classifier">str [if fringe is not ‘none’]</span></dt><dd><p>Name of fringe pair file (see e.g. <cite>setfringe</cite>). Required if
a fringe map has been specified.</p>
</dd>
<dt>nhalf<span class="classifier">int [if fringe is not ‘none’, hidden]</span></dt><dd><p>When calculating the differences for fringe measurement,
a region extending +/-nhalf binned pixels will be used when
measuring the amplitudes. Basically helps the stats.</p>
</dd>
<dt>rmin<span class="classifier">float [if fringe is not ‘none’, hidden]</span></dt><dd><p>Minimum individual ratio to accept prior to calculating the overall
median in order to reduce the effect of outliers. Although all ratios
should be positive, you might want to set this a little below zero
to allow for some statistical fluctuation.</p>
</dd>
<dt>rmax<span class="classifier">float [if fringe is not ‘none’, hidden]</span></dt><dd><p>Maximum individual ratio to accept prior to calculating the overall
median in order to reduce the effect of outliers. Probably typically
&lt; 1 if fringe map was created from longer exposure data.</p>
</dd>
<dt>log<span class="classifier">str</span></dt><dd><p>Name of reduce log file for light curve plot, ‘none’ to ignore</p>
</dd>
<dt>targ<span class="classifier">str [if log defined]</span></dt><dd><p>Target aperture</p>
</dd>
<dt>comp<span class="classifier">str [if log defined]</span></dt><dd><p>Comparison aperture</p>
</dd>
<dt>ymin<span class="classifier">float [if log defined]</span></dt><dd><p>Minimum Y value for light curve plot</p>
</dd>
<dt>ymax<span class="classifier">float [if log defined]</span></dt><dd><p>Maximum Y value for light curve plot</p>
</dd>
<dt>ynorm<span class="classifier">list(float) [if log defined]</span></dt><dd><p>Normalisation factors, one per CCD for light curve plot</p>
</dd>
<dt>yoffset<span class="classifier">list(float) [if log defined]</span></dt><dd><p>Offsets, one per CCD for light curve plot</p>
</dd>
<dt>location<span class="classifier">str [if log defined]</span></dt><dd><p>Offsets, one per CCD for light curve plot</p>
</dd>
<dt>fraction<span class="classifier">float [if log defined]</span></dt><dd><p>Fraction of figure to occupy, by height if location is South,
by width if it is East</p>
</dd>
<dt>lpad<span class="classifier">tuple(float) [if log defined]</span></dt><dd><p>padding on left, bottom, right and top of light curve plot as fraction
of allocated width and height</p>
</dd>
<dt>cmap<span class="classifier">str</span></dt><dd><p>The matplotlib colour map to use. “Greys” gives the usual greyscale.
“none” will give whatever the current default is. Many other choices:
“viridis”, “jet”, “hot”, “Oranges”, etc. Enter an invalid one and
the program will fail but return a huge list of possibles in the
process.</p>
</dd>
<dt>width<span class="classifier">float</span></dt><dd><p>plot width in inches.</p>
</dd>
<dt>height<span class="classifier">float</span></dt><dd><p>plot height in inches.</p>
</dd>
<dt>dstore<span class="classifier">str</span></dt><dd><p>root directory for plot files. Will get names like dstore/run003_001.png.</p>
</dd>
<dt>ndigit<span class="classifier">int</span></dt><dd><p>number of digits in frame counter, i.e. the ‘001’ of the previous section.</p>
</dd>
<dt>fext<span class="classifier">str</span></dt><dd><p>file extension ‘png’, ‘jpeg’ for images generated</p>
</dd>
<dt>msub<span class="classifier">bool</span></dt><dd><p>subtract the median from each window before scaling for the
image display or not. This happens after any bias subtraction.</p>
</dd>
<dt>iset<span class="classifier">str [single character]</span></dt><dd><p>determines how the intensities are determined. There are three
options: ‘a’ for automatic simply scales from the minimum to the
maximum value found on a per CCD basis. ‘d’ for direct just takes
two numbers from the user. ‘p’ for percentile dtermines levels
based upon percentiles determined from the entire CCD on a per CCD
basis.</p>
</dd>
<dt>ilo<span class="classifier">list(float) [if iset=’d’]</span></dt><dd><p>lower intensity level, one per image</p>
</dd>
<dt>ihi<span class="classifier">list(float) [if iset=’d’]</span></dt><dd><p>upper intensity level, one per image</p>
</dd>
<dt>plo<span class="classifier">float [if iset=’p’]</span></dt><dd><p>lower percentile level</p>
</dd>
<dt>phi<span class="classifier">float [if iset=’p’]</span></dt><dd><p>upper percentile level</p>
</dd>
<dt>xlo<span class="classifier">float</span></dt><dd><p>left-hand X-limit for plot, initially at least since it is
possible to re-size. For iset=’p’ these limits also set the
region of the frame over which the percentil will be
calculated. You will usually want yhi-ylo ~ xhi-xlo in
magnitude because the aspect ratio is preserved.</p>
</dd>
<dt>xhi<span class="classifier">float</span></dt><dd><p>right-hand X-limit for plot (can be &lt; xlo to invert the display)</p>
</dd>
<dt>ylo<span class="classifier">float</span></dt><dd><p>lower Y-limit for plot</p>
</dd>
<dt>yhi<span class="classifier">float</span></dt><dd><p>upper Y-limit for plot (can be &lt; ylo)</p>
</dd>
<dt>dpi<span class="classifier">int [hidden]</span></dt><dd><p>dots per inch of output. Default 72. Allows control over font size versus image size,
in combination with width and height.</p>
</dd>
<dt>style<span class="classifier">str [hidden, if log defined]</span></dt><dd><p>style for light curves ‘dots’, ‘line’, ‘both’. The line will be grey for the ‘both’ option.</p>
</dd>
<dt>ms<span class="classifier">float [hidden, if log defined and style==dots or both]</span></dt><dd><p>markersize. Controls dot size which is useful when fiddling with dpi</p>
</dd>
<dt>lw<span class="classifier">float [hidden, if log defined and style==line or both]</span></dt><dd><p>line width</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.mstats">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">mstats</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.mstats" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">mstats</span> <span class="pre">[source]</span> <span class="pre">run</span> <span class="pre">[temp]</span> <span class="pre">(ndigit)</span> <span class="pre">first</span> <span class="pre">last</span> <span class="pre">[twait</span> <span class="pre">tmax]</span> <span class="pre">bias</span>
<span class="pre">[dtype]</span></code></p>
<p>This downloads a sequence of images from a raw data file and writes 
out stats (min, max, mean, median, rms) for each window to a file</p>
<p>Parameters:</p>
<blockquote>
<div><dl>
<dt>source<span class="classifier">string [hidden]</span></dt><dd><p>Data source, four options:</p>
<blockquote>
<div><div class="line-block">
<div class="line">‘hs’ : HiPERCAM server</div>
<div class="line">‘hl’ : local HiPERCAM FITS file</div>
<div class="line">‘us’ : ULTRACAM server</div>
<div class="line">‘ul’ : local ULTRACAM .xml/.dat files</div>
</div>
</div></blockquote>
</dd>
<dt>run<span class="classifier">string</span></dt><dd><p>run name to access</p>
</dd>
<dt>first<span class="classifier">int</span></dt><dd><p>First frame to access</p>
</dd>
<dt>last<span class="classifier">int</span></dt><dd><p>Last frame to access, 0 for the lot</p>
</dd>
<dt>twait<span class="classifier">float [hidden]</span></dt><dd><p>time to wait between attempts to find a new exposure, seconds.</p>
</dd>
<dt>tmax<span class="classifier">float [hidden]</span></dt><dd><p>maximum time to wait between attempts to find a new exposure,
seconds.</p>
</dd>
<dt>bias<span class="classifier">string</span></dt><dd><p>Name of bias frame to subtract, ‘none’ to ignore.</p>
</dd>
<dt>format<span class="classifier">string</span></dt><dd><p>output format for numbers. e.g. the default ‘9.3f’
might give 12345.678 (9 characters, 3 digits after d.p.)</p>
</dd>
<dt>outfile<span class="classifier">string</span></dt><dd><p>file for output (extension .stats)</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.mul">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">mul</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.mul" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">mul</span> <span class="pre">input1</span> <span class="pre">input2</span> <span class="pre">[ccd</span> <span class="pre">win]</span> <span class="pre">output</span></code></p>
<p>Multiplies two hcm frames and outputs the result. Can be applied only to
particular CCDs and windows if wanted.</p>
<p>Parameters:</p>
<blockquote>
<div><dl class="simple">
<dt>input1<span class="classifier">string</span></dt><dd><p>first input hcm file</p>
</dd>
<dt>input2<span class="classifier">string</span></dt><dd><p>second input hcm file to multiply into the first.</p>
</dd>
<dt>ccd<span class="classifier">string [hidden, defaults to ‘all’]</span></dt><dd><p>the CCD or CCDs to apply the operation to. ‘all’ for the whole lot
which it returns to by default.  Can be several e.g. ‘2 4’ or just
one ‘3’</p>
</dd>
<dt>win<span class="classifier">string [hidden, defaults to ‘all’]</span></dt><dd><p>the CCD or CCDs to apply the operation to. ‘all’ for the whole lot
which it returns to by default.  Can be several e.g. ‘E2 G1’ or just
one ‘H1’. If you specify windows in this manner, it is assumed that
all the CCDs chosen in the previous input have the named windows;
‘all’ just applies the operation to all windows regardless.</p>
</dd>
<dt>output<span class="classifier">string</span></dt><dd><p>output hcm file name. Can be same as either input1 or input2
in which case the input file will be over-written.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.ncal">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">ncal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.ncal" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">ncal</span> <span class="pre">[source]</span> <span class="pre">(run</span> <span class="pre">first</span> <span class="pre">last</span> <span class="pre">[twait</span> <span class="pre">tmax]</span> <span class="pre">|</span> <span class="pre">flist)</span> <span class="pre">trim</span> <span class="pre">([ncol</span>
<span class="pre">nrow])</span> <span class="pre">(ccd)</span> <span class="pre">bias</span> <span class="pre">dark</span> <span class="pre">flat</span> <span class="pre">xybox</span> <span class="pre">read</span> <span class="pre">gain</span> <span class="pre">grain</span></code></p>
<p>Calibrates noise characteristics of CCDs by plotting estimator
of RMS vs signal level from a series of frames. The estimate
is the mean of the absolute difference between each pixel
and the mean of its 8 near-neighbours. This is very local and
fairly robust. Assuming gaussian noise, the RMS is sqrt(4*Pi/9)
times this value, and this is what is plotted as the RMS by this
routine. <cite>ncal</cite> is best to applied to a series of frames with
a large dynamic range, ideally starting from bias-like frames
to well exposed sky flats. A long flat-field run going to low
levels, or a run into twilight at the end of the night could be
good places to start.</p>
<p>Parameters:</p>
<blockquote>
<div><dl>
<dt>source<span class="classifier">str [hidden]</span></dt><dd><p>Data source, five options:</p>
<blockquote>
<div><div class="line-block">
<div class="line">‘hs’ : HiPERCAM server</div>
<div class="line">‘hl’ : local HiPERCAM FITS file</div>
<div class="line">‘us’ : ULTRACAM server</div>
<div class="line">‘ul’ : local ULTRACAM .xml/.dat files</div>
<div class="line">‘hf’ : list of HiPERCAM hcm FITS-format files</div>
</div>
</div></blockquote>
<p>‘hf’ is used to look at sets of frames generated by ‘grab’
or converted from foreign data formats. The standard
start-off default for <code class="docutils literal notranslate"><span class="pre">source</span></code> can be set using the
environment variable HIPERCAM_DEFAULT_SOURCE. e.g. in bash
<code class="code docutils literal notranslate"><span class="pre">export</span> <span class="pre">HIPERCAM_DEFAULT_SOURCE=&quot;us&quot;</span></code> would ensure it
always started with the ULTRACAM server by default. If
unspecified, it defaults to ‘hl’.</p>
</dd>
<dt>run<span class="classifier">str [if source ends ‘s’ or ‘l’]</span></dt><dd><p>run number to access, e.g. ‘run034’</p>
</dd>
<dt>flist<span class="classifier">str [if source ends ‘f’]</span></dt><dd><p>name of file list</p>
</dd>
<dt>first<span class="classifier">int [if source ends ‘s’ or ‘l’]</span></dt><dd><p>exposure number to start from. 1 = first frame; set = 0 to always
try to get the most recent frame (if it has changed).  For data
from the HiPERCAM server, a negative number tries to get a frame not
quite at the end.  i.e. -10 will try to get 10 from the last
frame. This is mainly to sidestep a difficult bug with the
acquisition system.</p>
</dd>
<dt>last<span class="classifier">int [if source ends ‘s’ or ‘l’]</span></dt><dd><p>Last frame to access, 0 for the lot</p>
</dd>
<dt>twait<span class="classifier">float [if source ends ‘s’ or ‘l’; hidden]</span></dt><dd><p>time to wait between attempts to find a new exposure, seconds.</p>
</dd>
<dt>tmax<span class="classifier">float [if source ends ‘s’ or ‘l’; hidden]</span></dt><dd><p>maximum time to wait between attempts to find a new exposure,
seconds.</p>
</dd>
<dt>trim<span class="classifier">bool [if source starts with ‘u’]</span></dt><dd><p>True to trim columns and/or rows off the edges of windows nearest
the readout which can sometimes contain bad data.</p>
</dd>
<dt>ncol<span class="classifier">int [if trim, hidden]</span></dt><dd><p>Number of columns to remove (on left of left-hand window, and right
of right-hand windows)</p>
</dd>
<dt>nrow<span class="classifier">int [if trim, hidden]</span></dt><dd><p>Number of rows to remove (bottom of windows)</p>
</dd>
<dt>ccd<span class="classifier">str</span></dt><dd><p>The CCD to analyse.</p>
</dd>
<dt>bias<span class="classifier">str</span></dt><dd><p>Name of bias frame to subtract, ‘none’ to ignore.</p>
</dd>
<dt>dark<span class="classifier">str</span></dt><dd><p>Name of dark frame to subtract, ‘none’ to ignore</p>
</dd>
<dt>flat<span class="classifier">str</span></dt><dd><p>Name of flat field to divide by, ‘none’ to ignore. Should normally
only be used in conjunction with a bias, although it does allow you
to specify a flat even if you haven’t specified a bias.</p>
</dd>
<dt>xybox<span class="classifier">int</span></dt><dd><p>the stats will be taken over boxes of xybox-squared pixels
to keep the number of points and scatter under control.</p>
</dd>
<dt>read<span class="classifier">float</span></dt><dd><p>readout noise, RMS ADU, for overplotting a model</p>
</dd>
<dt>gain<span class="classifier">float</span></dt><dd><p>gain, e-/count, for overploting a model</p>
</dd>
<dt>grain<span class="classifier">float</span></dt><dd><p>fractional RMS variation due to flat-field variations,
if you didn’t include a flat field.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.nrtplot">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">nrtplot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.nrtplot" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">nrtplot</span> <span class="pre">[source]</span> <span class="pre">(run</span> <span class="pre">first</span> <span class="pre">[twait</span> <span class="pre">tmax]</span> <span class="pre">|</span> <span class="pre">flist)</span> <span class="pre">trim</span> <span class="pre">([ncol</span>
<span class="pre">nrow])</span> <span class="pre">(ccd</span> <span class="pre">(nx))</span> <span class="pre">[imwidth</span> <span class="pre">pause</span> <span class="pre">tupdate</span> <span class="pre">plotall]</span> <span class="pre">bias</span> <span class="pre">[lowlevel</span>
<span class="pre">highlevel]</span> <span class="pre">dark</span> <span class="pre">flat</span> <span class="pre">fmap</span> <span class="pre">(fpair</span> <span class="pre">[nhalf</span> <span class="pre">rmin</span> <span class="pre">rmax])</span> <span class="pre">defect</span> <span class="pre">setup</span>
<span class="pre">[drurl</span> <span class="pre">cmap</span> <span class="pre">imwidth</span> <span class="pre">imheight</span> <span class="pre">memory]</span> <span class="pre">msub</span> <span class="pre">iset</span> <span class="pre">(ilo</span> <span class="pre">ihi</span> <span class="pre">|</span> <span class="pre">plo</span> <span class="pre">phi)</span>
<span class="pre">xlo</span> <span class="pre">xhi</span> <span class="pre">ylo</span> <span class="pre">yhi</span> <span class="pre">profit</span> <span class="pre">[method</span> <span class="pre">beta</span> <span class="pre">fwhm</span> <span class="pre">fwhm_min</span> <span class="pre">shbox</span> <span class="pre">smooth</span>
<span class="pre">fhbox</span> <span class="pre">hmin</span> <span class="pre">read</span> <span class="pre">gain</span> <span class="pre">thresh</span> <span class="pre">(fwnmax</span> <span class="pre">fwymax</span> <span class="pre">fwwidth</span> <span class="pre">fwheight)]</span>
<span class="pre">[fcosmic]</span> <span class="pre">(contrast</span> <span class="pre">crthresh</span> <span class="pre">nbthresh</span> <span class="pre">sathresh</span> <span class="pre">readout)</span></code></p>
<p>This is ‘nrtplot’ “new” rtplot, a matplotlib-based replacement for
the current PGPLOT one. Under development.</p>
<p>Plots a sequence of images as a movie in near ‘real time’, hence
‘rt’. Designed to be used to look at images coming in while at the
telescope, ‘nrtplot’ comes with many options, a large number of
which are hidden by default, and many of which are only prompted
if other arguments are set correctly. If you want to see them all,
invoke as ‘nrtplot prompt’.  This is worth doing once to know
nrtplot’s capabilities.</p>
<p>nrtplot can source data from both the ULTRACAM and HiPERCAM
servers, from local ‘raw’ ULTRACAM and HiPERCAM files (i.e. .xml +
.dat for ULTRACAM, 3D FITS files for HiPERCAM) and from lists of
HiPERCAM ‘.hcm’ files.</p>
<p>nrtplot optionally allows the selection of targets to be fitted
with gaussian or moffat profiles, and, if successful, will plot
circles of 2x the measured FWHM in green over the selected
targets. In this case it can also plot the history of the FWHMs as
an aid to focussing. You can also click on targets on the fly to
get one-off measurement which are just printed to the screen. See
below for a note on this.</p>
<p>You can re-size and zoom &amp; pan during plotting, although it takes
some getting used owing to the way the program blocks. For re-sizing,
you may need to keep the left-button of the mouse down for a while
for anything to happen. See the parameter ‘memory’ below which can
help.</p>
<p>When you first run it, try to get the initial fit parameters about
right; it doesn’t like to be miles out at the start for some reason
and will refuse to fit.</p>
<p>Experimental: I have added options to apply L.A.cosmic just to see what
it returns at the moment.</p>
<p>Parameters:</p>
<blockquote>
<div><dl>
<dt>source<span class="classifier">str [hidden]</span></dt><dd><p>Data source, five options:</p>
<blockquote>
<div><div class="line-block">
<div class="line">‘hs’ : HiPERCAM server</div>
<div class="line">‘hl’ : local HiPERCAM FITS file</div>
<div class="line">‘us’ : ULTRACAM server</div>
<div class="line">‘ul’ : local ULTRACAM .xml/.dat files</div>
<div class="line">‘hf’ : list of HiPERCAM hcm FITS-format files</div>
</div>
</div></blockquote>
<p>‘hf’ is used to look at sets of frames generated by ‘grab’
or converted from foreign data formats. The standard
start-off default for <code class="docutils literal notranslate"><span class="pre">source</span></code> can be set using the
environment variable HIPERCAM_DEFAULT_SOURCE. e.g. in bash
<code class="code docutils literal notranslate"><span class="pre">export</span> <span class="pre">HIPERCAM_DEFAULT_SOURCE=&quot;us&quot;</span></code> would ensure it
always started with the ULTRACAM server by default. If
unspecified, it defaults to ‘hl’.</p>
</dd>
<dt>run<span class="classifier">str [if source ends ‘s’ or ‘l’]</span></dt><dd><p>run number to access, e.g. ‘run034’</p>
</dd>
<dt>flist<span class="classifier">str [if source ends ‘f’]</span></dt><dd><p>name of file list</p>
</dd>
<dt>first<span class="classifier">int [if source ends ‘s’ or ‘l’]</span></dt><dd><p>exposure number to start from. 1 = first frame; set = 0 to always
try to get the most recent frame (if it has changed).  For data
from the HiPERCAM server, a negative number tries to get a frame not
quite at the end.  i.e. -10 will try to get 10 from the last
frame. This is mainly to sidestep a difficult bug with the
acquisition system.</p>
</dd>
<dt>twait<span class="classifier">float [if source ends ‘s’ or ‘l’; hidden]</span></dt><dd><p>time to wait between attempts to find a new exposure, seconds.</p>
</dd>
<dt>tmax<span class="classifier">float [if source ends ‘s’ or ‘l’; hidden]</span></dt><dd><p>maximum time to wait between attempts to find a new exposure,
seconds.</p>
</dd>
<dt>trim<span class="classifier">bool [if source starts with ‘u’]</span></dt><dd><p>True to trim columns and/or rows off the edges of windows nearest
the readout which can sometimes contain bad data.</p>
</dd>
<dt>ncol<span class="classifier">int [if trim, hidden]</span></dt><dd><p>Number of columns to remove (on left of left-hand window, and right
of right-hand windows)</p>
</dd>
<dt>nrow<span class="classifier">int [if trim, hidden]</span></dt><dd><p>Number of rows to remove (bottom of windows)</p>
</dd>
<dt>ccd<span class="classifier">str</span></dt><dd><p>CCD(s) to plot, ‘0’ for all, ‘1 3’ to plot ‘1’ and ‘3’ only, etc.</p>
</dd>
<dt>nx<span class="classifier">int [if more than 1 CCD]</span></dt><dd><p>number of panels across to display for the image display.</p>
</dd>
<dt>pause<span class="classifier">float [hidden]</span></dt><dd><p>seconds to pause between frames (defaults to 0). This is in addition
to any time taken per frame to read and display it, so is just to slow
things not to set an exact rate.</p>
</dd>
<dt>tupdate<span class="classifier">float [hidden]</span></dt><dd><p>target number of seconds between plot updates. This is to
make the plots more responsive and get round issues with
plots freezing until the next frame comes through which can
be especially annoying with virtual desktops. Experiments
with <a class="reference external" href="mailto:ULTRACAM&#37;&#52;&#48;NTT">ULTRACAM<span>&#64;</span>NTT</a> indicated 0.2 to 0.6 secs or so works OK.
Main impact seems to be on drpc CPU.</p>
</dd>
<dt>plotall<span class="classifier">bool [hidden]</span></dt><dd><p>plot all frames regardless of status (i.e. including blank frames
when nskips are enabled (defaults to False). The profile fitting
will still be disabled for bad frames.</p>
</dd>
<dt>bias<span class="classifier">str</span></dt><dd><p>Name of bias frame to subtract, ‘none’ to ignore.</p>
</dd>
<dt>lowlevel<span class="classifier">float [hidden]</span></dt><dd><p>Level below which a warning about low bias levels is warned. Set=0
to ignore. Applied to first window of first CCD. 2000 about
right for ULTRACAM.</p>
</dd>
<dt>highlevel<span class="classifier">float [hidden]</span></dt><dd><p>Level above which a warning about high bias levels is warned. Set=0
to ignore. Applied to first window of first CCD. 3500 about
right for ULTRACAM.</p>
</dd>
<dt>dark<span class="classifier">str</span></dt><dd><p>Name of dark frame to subtract, ‘none’ to ignore</p>
</dd>
<dt>flat<span class="classifier">str</span></dt><dd><p>Name of flat field to divide by, ‘none’ to ignore. Should normally
only be used in conjunction with a bias, although it does allow you
to specify a flat even if you haven’t specified a bias.</p>
</dd>
<dt>fmap<span class="classifier">str</span></dt><dd><p>Name of fringe map (see e.g. <cite>makefringe</cite>), ‘none’ to ignore.</p>
</dd>
<dt>fpair<span class="classifier">str [if fmap is not ‘none’]</span></dt><dd><p>Name of fringe pair file (see e.g. <cite>setfringe</cite>). Required if
a fringe map has been specified.</p>
</dd>
<dt>nhalf<span class="classifier">int [if fmap is not ‘none’, hidden]</span></dt><dd><p>When calculating the differences for fringe measurement,
a region extending +/-nhalf binned pixels will be used when
measuring the amplitudes. Basically helps the stats.</p>
</dd>
<dt>rmin<span class="classifier">float [if fmap is not ‘none’, hidden]</span></dt><dd><p>Minimum individual ratio to accept prior to calculating the overall
median in order to reduce the effect of outliers. Although all ratios
should be positive, you might want to set this a little below zero
to allow for some statistical fluctuation.</p>
</dd>
<dt>rmax<span class="classifier">float [if fmap is not ‘none’, hidden]</span></dt><dd><p>Maximum individual ratio to accept prior to calculating the overall
median in order to reduce the effect of outliers. Probably typically
&lt; 1 if fringe map was created from longer exposure data.</p>
</dd>
<dt>defect<span class="classifier">str</span></dt><dd><p>Name of defect file, ‘none’ to ignore.</p>
</dd>
<dt>setup<span class="classifier">bool</span></dt><dd><p>True/yes to access the current windows from hdriver. Useful
during observing when setting up windows, but not normally
otherwise. Next argument (hidden) is the URL to get to
hdriver. Once setup, you should probably turn this off to
avoid overloading hdriver, especially if in drift mode as
it makes a request for the windows for every frame.</p>
</dd>
<dt>drurl<span class="classifier">str [if setup; hidden]</span></dt><dd><p>URL needed to access window setting from the camera
driver (ultracam, ultraspec, hipercam). The internal server
in the camera driver must be switched on which can be done
from the GUI.</p>
</dd>
<dt>cmap<span class="classifier">str [hidden]</span></dt><dd><p>The matplotlib colour map to use. “Greys” gives the usual greyscale.
“none” will give whatever the current default is. Many other choices:
“viridis”, “jet”, “hot”, “Oranges”, etc. Enter an invalid one and
the program will fail but return a huge list of possibles in the
process. Note that some will not work well with the colours used
to plot annotations.</p>
</dd>
<dt>imwidth<span class="classifier">float [hidden]</span></dt><dd><p>image display plot width in inches (0 for default, and note
that this will also make the height go to its default)</p>
</dd>
<dt>imheight<span class="classifier">float [hidden]</span></dt><dd><p>image display plot height in inches (0 for default, and note
that this will also make the width go to its default)</p>
</dd>
<dt>memory<span class="classifier">bool [hidden]</span></dt><dd><p>stores the image display dimensions at the end as defaults for
imwidth and imheight next time (or not). This helps when you are
repeatedly re-starting nrtplot for the same sort of display.</p>
</dd>
<dt>msub<span class="classifier">bool</span></dt><dd><p>subtract the median from each window before scaling for the
image display or not. This happens after any bias subtraction.</p>
</dd>
<dt>iset<span class="classifier">str [single character]</span></dt><dd><p>determines how the intensities are determined. There are three
options: ‘a’ for automatic simply scales from the minimum to the
maximum value found on a per CCD basis. ‘d’ for direct just takes
two numbers from the user. ‘p’ for percentile dtermines levels
based upon percentiles determined from the entire CCD on a per CCD
basis.</p>
</dd>
<dt>ilo<span class="classifier">float [if iset=’d’]</span></dt><dd><p>lower intensity level</p>
</dd>
<dt>ihi<span class="classifier">float [if iset=’d’]</span></dt><dd><p>upper intensity level</p>
</dd>
<dt>plo<span class="classifier">float [if iset=’p’]</span></dt><dd><p>lower percentile level</p>
</dd>
<dt>phi<span class="classifier">float [if iset=’p’]</span></dt><dd><p>upper percentile level</p>
</dd>
<dt>xlo<span class="classifier">float</span></dt><dd><p>left-hand X-limit for plot, initially at least since it is
possible to re-size. For iset=’p’ these limits also set the
region of the frame over which the percentil will be
calculated. You will usually want yhi-ylo ~ xhi-xlo in
magnitude because the aspect ratio is preserved.</p>
</dd>
<dt>xhi<span class="classifier">float</span></dt><dd><p>right-hand X-limit for plot (can be &lt; xlo to invert the display)</p>
</dd>
<dt>ylo<span class="classifier">float</span></dt><dd><p>lower Y-limit for plot</p>
</dd>
<dt>yhi<span class="classifier">float</span></dt><dd><p>upper Y-limit for plot (can be &lt; ylo)</p>
</dd>
<dt>profit<span class="classifier">bool</span></dt><dd><p>If profit=True, you say yes, then you will get the option
of selecting a fixed set of objects with a cursor, and the
program will then attempt to track these from frame to
frame, and fit their profile. You may need to adjust
‘first’ to see anything. Depending on ‘fnmax’, it will also
then plot a history of the FWHM measurements, which is
useful for focussing. The parameters used for profile fits
are hidden and you may want to invoke the command with
‘prompt’ the first time you try profile fitting. NB There
is also an option for “on-the-fly” fits of any target: see
the note below.</p>
</dd>
<dt>method<span class="classifier">str [hidden]</span></dt><dd><p>this defines the profile fitting method, either a gaussian or a
moffat profile. The latter is usually best.</p>
</dd>
<dt>beta<span class="classifier">float [method == ‘m’; hidden]</span></dt><dd><p>default Moffat exponent</p>
</dd>
<dt>fwhm<span class="classifier">float [hidden]</span></dt><dd><p>default FWHM, unbinned pixels. Do try to get this about right as
it affects whether the profile can be fitted at all.</p>
</dd>
<dt>fwhm_min<span class="classifier">float [hidden]</span></dt><dd><p>minimum FWHM to allow, unbinned pixels.</p>
</dd>
<dt>shbox<span class="classifier">float [hidden]</span></dt><dd><p>half width of box for searching for a star, unbinned
pixels. The above-threshold target closest to the centre of
the box in a region +/- shbox around an intial position
will be selected. It may not be the brightest, depending
upon your threshold settings, so use those to filter faint
objects. If profit=True, ‘shbox’ should be large enough to
allow for likely changes in position from frame to frame,
but not too large to avoid jumping to brighter targets or
possibly cosmic rays.</p>
</dd>
<dt>smooth<span class="classifier">float [hidden]</span></dt><dd><p>FWHM for gaussian smoothing, binned pixels. The initial position
for fitting is determined by finding the maximum flux in a smoothed
version of the image in a box of width +/- shbox around the starter
position. Typically should be comparable to the stellar width. Its
main purpose is to combat cosmic rays which tend only to occupy a
single pixel.</p>
</dd>
<dt>fhbox<span class="classifier">float [hidden]</span></dt><dd><p>half width of box for profile fit, unbinned pixels. The fit box is
centred on the position located by the initial search. It should
normally be &gt; ~2x the expected FWHM, and usually smaller than shbox</p>
</dd>
<dt>hmin<span class="classifier">float [hidden]</span></dt><dd><p>height threshold to accept a fit. If the height is below this
value, the position will not be updated. This is to help in cloudy
conditions. The limit is applied to the image after it has been
smoothed to make less vulnerable to seeing fluctuations. This
can mean it can be quite small.</p>
</dd>
<dt>read<span class="classifier">float [hidden]</span></dt><dd><p>readout noise, RMS ADU, for assigning uncertainties. Set to a -ve
value to try to ascertain on the fly; this is advisable either if
you don’t have a bias or you apply ‘msub’, and it will default to
this if not specified in this case. The value returned in this case
includes sky noise, i.e it should be roughly sqrt(R**2+S/G) where
R is the true read noise, S are the sky counts per pixel, and G the
gain. If read is set -ve, two fits are carried out per target. The
second of these should usually be pretty fast. The first is carried
out with an assumed large read noise of 20 in order to soften the
weights. The results reported apply to the second fit.</p>
</dd>
<dt>gain<span class="classifier">float [hidden]</span></dt><dd><p>gain, ADU/count, for assigning uncertainties.</p>
</dd>
<dt>thresh<span class="classifier">float [hidden]</span></dt><dd><p>sigma rejection threshold for fits</p>
</dd>
<dt>fwnmax<span class="classifier">int [if profit; hidden]</span></dt><dd><p>maximum number of frames to buffer the FWHM plot (&lt; 2 ==&gt;
no plot). It allows the FWHMs of multiple stars to be
tracked which might be useful for focussing. The plot
starts to “slide” once the buffers are filled.</p>
</dd>
<dt>fwymax<span class="classifier">float [if profit; hidden]</span></dt><dd><p>maximum FWHM to plot on Y-axis [unbinned pixels]. It is
possible to alter the value of the fly by zooming and panning
the plot.</p>
</dd>
<dt>fwwidth<span class="classifier">float [if profit; hidden]</span></dt><dd><p>FWHM display plot width in inches (0 for default, which will
also cause the height to go to its default value)</p>
</dd>
<dt>fwheight<span class="classifier">float [if profit; hidden]</span></dt><dd><p>FWHM display plot height in inches (0 for default, which will
also cause the width to go to its default value)</p>
</dd>
<dt>fcosmic<span class="classifier">bool [hidden, defaults to False]</span></dt><dd><p>True to identify cosmic rays using L.A.cosmic (van Dokkum 2001,
PASP, 113, 1420) as implemented in Python package “lascosmic”.
Experimental at the moment. Just returns the number of cosmic
rays found.</p>
</dd>
<dt>crthresh<span class="classifier">float</span></dt><dd><p>Threshold signal-to-noise ratio of cosmic rays</p>
</dd>
<dt>nbthresh<span class="classifier">float</span></dt><dd><p>Threshold signal-to-noise ratio of pixels neighbouring
cosmic rays</p>
</dd>
<dt>sathresh<span class="classifier">float</span></dt><dd><p>Threshold to flag saturated pixels</p>
</dd>
<dt>readout<span class="classifier">float</span></dt><dd><p>readout noise, RMS ADU, for assigning uncertainties. (NB
at the moment this is separate from “read”, but they may
be merged at some point)</p>
</dd>
</dl>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To help with <em>dithered</em> long exposures especially, for which
‘profit’ performs very poorly, clicking on any object will
attempt a one-off profile fit, with results that are reported
to the terminal. It’s a little cludgy in that the profile fits
are only carried out and reported <em>after</em> the next frame has
been plotted, but it’s better than nothing.</p>
<p>If you don’t apply bias subtraction and/or you do subtract the
median, then the usual method to estimate the read noise fails.
In that case, setting ‘read’ &lt; 0 will force an attempt to measure
the read noise from fluctuations in the sky. You need to ensure
that fhbox is large enough to encompass sky regions well away from
the target in this case.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.pbands">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">pbands</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.pbands" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">pbands</span> <span class="pre">log</span> <span class="pre">[device</span> <span class="pre">(dpi)</span> <span class="pre">width</span> <span class="pre">height</span> <span class="pre">ms</span> <span class="pre">line</span> <span class="pre">error]</span> <span class="pre">norm</span> <span class="pre">zero</span> <span class="pre">[plo</span> <span class="pre">phi</span> <span class="pre">increment]</span>
<span class="pre">pgram</span> <span class="pre">(flo</span> <span class="pre">fhi</span> <span class="pre">over)</span> <span class="pre">title</span></code></p>
<p>Plots a HiPERCAM <a class="reference internal" href="#hipercam.scripts.reduce" title="hipercam.scripts.reduce"><code class="xref py py-func docutils literal notranslate"><span class="pre">reduce</span></code></a> log as a single light curve in one panel
per CCD. Can optionally be normalised and the y-axis origin set to
zero, and can also include periodogram plots if wanted. The
purpose of the routine is to facilitate quick-look plots during
observing runs.</p>
<p>Parameters:</p>
<blockquote>
<div><dl class="simple">
<dt>log<span class="classifier">string</span></dt><dd><p>name of <a class="reference internal" href="#hipercam.scripts.reduce" title="hipercam.scripts.reduce"><code class="xref py py-func docutils literal notranslate"><span class="pre">reduce</span></code></a> ASCII log file (text file with loads of columns)</p>
</dd>
<dt>device<span class="classifier">string [hidden, defaults to ‘term’]</span></dt><dd><p>‘term’ for interactive plot, file name such as ‘plot.pdf’
or ‘object.png’ for a hardcopy.</p>
</dd>
<dt>dpi<span class="classifier">int [hidden, if device ends .png]</span></dt><dd><p>dots per inch for png output</p>
</dd>
<dt>width<span class="classifier">float [hidden]</span></dt><dd><p>plot width (inches). Set = 0 to let the program choose.</p>
</dd>
<dt>height<span class="classifier">float [hidden]</span></dt><dd><p>plot height (inches). Set = 0 to let the program choose. BOTH
width AND height must be non-zero to have any effect</p>
</dd>
<dt>ms<span class="classifier">float [hidden]</span></dt><dd><p>marker size</p>
</dd>
<dt>line<span class="classifier">bool [hidden]</span></dt><dd><p>connect points with a line or not</p>
</dd>
<dt>error<span class="classifier">bool [hidden]</span></dt><dd><p>plot error bars or not</p>
</dd>
<dt>norm<span class="classifier">bool</span></dt><dd><p>normalise each light curve to a unit median (or not)</p>
</dd>
<dt>zero<span class="classifier">bool</span></dt><dd><p>set y-axis origin to zero</p>
</dd>
<dt>plo<span class="classifier">float [hidden]</span></dt><dd><p>percentile to use to set the lower limit of the lightcurve plots
(e.g. 5). Takes account of error bars.</p>
</dd>
<dt>phi<span class="classifier">float [hidden]</span></dt><dd><p>percentile to use to set the upper limit of the lightcurve plot
(e.g. 95). Must be &gt; plo. Takes account of error bars.</p>
</dd>
<dt>increment<span class="classifier">float [hidden]</span></dt><dd><p>fraction of plot range that comes from plo, phi to add on top and bottom.
If the initial numbers are y1 and y2, then each is corrected up and down by
increment*(y2-y1), but if “zero” then y1 is set = 0.</p>
</dd>
<dt>pgram<span class="classifier">bool</span></dt><dd><p>plot periodogram panels (or not). They appear on the right-hand
side if yes.</p>
</dd>
<dt>flo<span class="classifier">float (if pgram)</span></dt><dd><p>If pgram, the mimimum frequency for the periodogram plots,
cycles per day. Typically there is little point pushing flo
very far below 1 cycle over the timespan of the data.</p>
</dd>
<dt>fhi<span class="classifier">float (if pgram)</span></dt><dd><p>If pgram, the maximum frequency for the periodogram plots
cycles per day. The maximum useful is set by the Nyquist
limit (1 cycle per 2 exposures). e.g. For 10 second cadence,
this would be be 86400/10/2 = 4320 cycles/day.</p>
</dd>
<dt>over<span class="classifier">float (if pgram)</span></dt><dd><p>If pgram, the oversampling factor to determine the frequency grid.
Corresponds to the “sample_per_peak” parameter of the astropy
LombScargle routine.</p>
</dd>
<dt>title<span class="classifier">str</span></dt><dd><p>plot title. Defaults to name of log file</p>
</dd>
<dt>colours<span class="classifier">list of strings</span></dt><dd><p>colours for each CCD, space or comma-separated.
e.g. “r,g,b” or “r g b” (without quotes).</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.plog">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">plog</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.plog" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">plog</span> <span class="pre">log</span> <span class="pre">[device</span> <span class="pre">width</span> <span class="pre">height]</span> <span class="pre">ccd1</span> <span class="pre">aper1</span> <span class="pre">param1</span> <span class="pre">ccd2</span> <span class="pre">(aper2</span> <span class="pre">param2</span>
<span class="pre">scheme)</span> <span class="pre">[title]</span></code></p>
<p>Provides quick-look plots of HiPERCAM <a class="reference internal" href="#hipercam.scripts.reduce" title="hipercam.scripts.reduce"><code class="xref py py-func docutils literal notranslate"><span class="pre">reduce</span></code></a> logs.</p>
<p>Parameters:</p>
<blockquote>
<div><dl>
<dt>log<span class="classifier">string</span></dt><dd><p>name of <a class="reference internal" href="#hipercam.scripts.reduce" title="hipercam.scripts.reduce"><code class="xref py py-func docutils literal notranslate"><span class="pre">reduce</span></code></a> ASCII log file (text file with loads of columns)</p>
</dd>
<dt>device<span class="classifier">string [hidden, defaults to ‘term’]</span></dt><dd><p>‘term’ for interactive plot, file name such as ‘plot.pdf’
for a hardcopy.</p>
</dd>
<dt>width<span class="classifier">float [hidden]</span></dt><dd><p>plot width (inches). Set = 0 to let the program choose.</p>
</dd>
<dt>height<span class="classifier">float [hidden]</span></dt><dd><p>plot height (inches). Set = 0 to let the program choose. BOTH
width AND height must be non-zero to have any effect</p>
</dd>
<dt>ccd1<span class="classifier">str</span></dt><dd><p>first CCD to consider, e.g. ‘1’</p>
</dd>
<dt>aper1<span class="classifier">str</span></dt><dd><p>first aperture to consider</p>
</dd>
<dt>param1<span class="classifier">str</span></dt><dd><p>first parameter to consider. Choices are ‘x’ = X position,
‘y’ = Y position, ‘f’ = FWHM, ‘b’ = Moffat beta, ‘s’ = sky,
‘m’ = maximum counts in aperture</p>
</dd>
<dt>ccd2<span class="classifier">str</span></dt><dd><p>second CCD to consider; ‘!’ to ignore. Can be (and typically
would be) the same as ccd1.</p>
</dd>
<dt>aper2<span class="classifier">str [if ccd2 != ‘!’]</span></dt><dd><p>second aperture to consider</p>
</dd>
<dt>param2<span class="classifier">str [if ccd2 != ‘!’]</span></dt><dd><p>second parameter. See param1 for choices</p>
</dd>
<dt>scheme<span class="classifier">str [if ccd2 != ‘!’]</span></dt><dd><p>how to plot if both apertures are chosen. Choices:</p>
<blockquote>
<div><div class="line-block">
<div class="line">‘d’ = difference, i.e. plot 1-2</div>
<div class="line">‘b’ = both plotted on same panel</div>
<div class="line">‘r’ = ratio, i.e. 1 / 2, good for relative photom</div>
<div class="line">‘s’ = scatter plot, 2 vs 1.</div>
</div>
</div></blockquote>
</dd>
<dt>title<span class="classifier">str [hidden]</span></dt><dd><p>plot title. Defaults to the run number if not specified</p>
</dd>
</dl>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Points marked bad, or flagged as having bad times or junk are
ignored. i.e.  bitmask = BAD_TIME | JUNK is passed to every
invocation of Tseries.mplot.  Be careful with linked apertures
where all x, y, FWHM, beta automatically have negative errors
since they are not fitted. See <a class="reference internal" href="#hipercam.scripts.flagcloud" title="hipercam.scripts.flagcloud"><code class="xref py py-func docutils literal notranslate"><span class="pre">flagcloud</span></code></a> for how to flag up
junk data.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.redanal">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">redanal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.redanal" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">redanal</span> <span class="pre">aper</span> <span class="pre">log</span></code></p>
<p>This provides some basic stats on a log file such as the fraction of duff
points for each aperture of each CCD, how much targets have moved and the
like. The aim is to help with setting parameters in the reduce file in
difficult cases and to diagnose problems. It will probably be added to with
time.</p>
<p>Parameters:</p>
<blockquote>
<div><dl class="simple">
<dt>aper<span class="classifier">string</span></dt><dd><p>the aperture file used for the reduction.</p>
</dd>
<dt>log<span class="classifier">string</span></dt><dd><p>the log file.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.reduce">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">reduce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.reduce" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">reduce</span> <span class="pre">[source]</span> <span class="pre">rfile</span> <span class="pre">(run</span> <span class="pre">first</span> <span class="pre">last</span> <span class="pre">[twait</span> <span class="pre">tmax]|</span> <span class="pre">flist)</span> <span class="pre">trim</span>
<span class="pre">([ncol</span> <span class="pre">nrow])</span> <span class="pre">log</span> <span class="pre">lplot</span> <span class="pre">implot</span> <span class="pre">(ccd</span> <span class="pre">nx</span> <span class="pre">msub</span> <span class="pre">xlo</span> <span class="pre">xhi</span> <span class="pre">ylo</span> <span class="pre">yhi</span> <span class="pre">iset</span>
<span class="pre">(ilo</span> <span class="pre">ihi</span> <span class="pre">|</span> <span class="pre">plo</span> <span class="pre">phi))</span></code></p>
<p>Reduces a sequence of multi-CCD images, plotting lightcurves as
images come in. It can extract with either simple aperture
photometry or Tim Naylor’s optimal photometry, on specific targets
defined in an aperture file using <a class="reference internal" href="#hipercam.scripts.setaper" title="hipercam.scripts.setaper"><code class="xref py py-func docutils literal notranslate"><span class="pre">setaper</span></code></a>.</p>
<p>reduce can source data from both the ULTRACAM and HiPERCAM
servers, from local ‘raw’ ULTRACAM and HiPERCAM files (i.e. .xml +
.dat for ULTRACAM, 3D FITS files for HiPERCAM) and from lists of
HiPERCAM ‘.hcm’ files. If you have data from a different
instrument you should convert into the FITS-based hcm format.</p>
<p>reduce is primarily configured from a file with extension
“.red”. This contains a series of directives, e.g. to say how to
re-position and re-size the apertures. An initial reduce file is
best generated with the script <a class="reference internal" href="#hipercam.scripts.genred" title="hipercam.scripts.genred"><code class="xref py py-func docutils literal notranslate"><span class="pre">genred</span></code></a> after you have created an
aperture file. This contains lots of help on what to do. <a class="reference internal" href="#hipercam.scripts.genred" title="hipercam.scripts.genred"><code class="xref py py-func docutils literal notranslate"><span class="pre">genred</span></code></a>
tries to get something usable fast for observing purposes, but the
parameters can nearly always be tweaked to produce better
outcomes.</p>
<p>A reduce run can be terminated at any point with ctrl-C without doing
any harm. You may often want to do this at the start in order to adjust
parameters of the reduce file.</p>
<p>Parameters:</p>
<blockquote>
<div><dl>
<dt>source<span class="classifier">str [hidden]</span></dt><dd><p>Data source, five options:</p>
<blockquote>
<div><div class="line-block">
<div class="line">‘hs’: HiPERCAM server</div>
<div class="line">‘hl’: local HiPERCAM FITS file</div>
<div class="line">‘us’: ULTRACAM server</div>
<div class="line">‘ul’: local ULTRACAM .xml/.dat files</div>
<div class="line">‘hf’: list of HiPERCAM hcm FITS-format files</div>
</div>
</div></blockquote>
<p>‘hf’ is used to look at sets of frames generated by ‘grab’
or converted from foreign data formats. The standard
start-off default for <code class="docutils literal notranslate"><span class="pre">source</span></code> can be set using the
environment variable HIPERCAM_DEFAULT_SOURCE. e.g. in bash
<code class="code docutils literal notranslate"><span class="pre">export</span> <span class="pre">HIPERCAM_DEFAULT_SOURCE=&quot;us&quot;</span></code> would ensure it
always started with the ULTRACAM server by default.  If
unspecified, it defaults to ‘hl’.</p>
</dd>
<dt>run<span class="classifier">str [if source ends ‘s’ or ‘l’]</span></dt><dd><p>run number to access, e.g. ‘run034’ or a file list. If a run,
then reduce and log below will be set to have the same name by
default.</p>
</dd>
<dt>first<span class="classifier">int [if source ends ‘s’ or ‘l’]</span></dt><dd><p>first frame to reduce. 1 = first frame; set = 0 to always try to
get the most recent frame (if it has changed).</p>
</dd>
<dt>last<span class="classifier">int [if source ends ‘s’ or ‘l’, hidden]</span></dt><dd><p>last frame to reduce. 0 to just continue until the end.  This is
not prompted for by default and must be set explicitly.  It
defaults to 0 if not set. Its purpose is to allow accurate
profiling tests.</p>
</dd>
<dt>twait<span class="classifier">float [if source ends ‘s’; hidden]</span></dt><dd><p>time to wait between attempts to find a new exposure, seconds.</p>
</dd>
<dt>tmax<span class="classifier">float [if source ends ‘s’; hidden]</span></dt><dd><p>maximum time to wait between attempts to find a new exposure,
seconds.</p>
</dd>
<dt>flist<span class="classifier">string [if source ends ‘f’]</span></dt><dd><p>name of file list</p>
</dd>
<dt>trim<span class="classifier">bool</span></dt><dd><p>True to trim columns and/or rows off the edges of windows nearest
the readout. Particularly useful with ULTRACAM windowed data where
the first few rows and columns can contain bad data.</p>
</dd>
<dt>ncol<span class="classifier">int [if trim, hidden]</span></dt><dd><p>Number of columns to remove (on left of left-hand window, and right
of right-hand windows)</p>
</dd>
<dt>nrow<span class="classifier">int [if trim, hidden]</span></dt><dd><p>Number of rows to remove (bottom of windows)</p>
</dd>
<dt>rfile<span class="classifier">str</span></dt><dd><p>the “reduce” file, i.e. ASCII text file suitable for reading by
ConfigParser. Best seen by example as it has many parts. If you
are reducing a run, this will be set to have the same root name by
default (but a different extension to avoid name clashes).</p>
</dd>
<dt>log<span class="classifier">str</span></dt><dd><p>log file for the results. If you are reducing a run, this
will be set to have the same root name by default (but a
different extension to avoid name clashes)</p>
</dd>
<dt>tkeep<span class="classifier">float</span></dt><dd><p>maximum number of minutes of data to store in internal buffers, 0
for the lot. When large numbers of frames are stored, performance
can be slowed (although I am not entirely clear why) in which case
it makes sense to lose the earlier points (without affecting the
saving to disk). This parameter also gives operation similar to that
of “max_xrange” parameter in the ULTRACAM pipeline whereby just
the last few minutes are shown.</p>
</dd>
<dt>lplot<span class="classifier">bool</span></dt><dd><p>flag to indicate you want to plot the light curve. Saves time not
to especially in high-speed runs.</p>
</dd>
<dt>implot<span class="classifier">bool</span></dt><dd><p>flag to indicate you want to plot images.</p>
</dd>
<dt>ccd<span class="classifier">string [if implot]</span></dt><dd><p>CCD(s) to plot, ‘0’ for all, ‘1 3’ to plot ‘1’ and ‘3’ only, etc.</p>
</dd>
<dt>nx<span class="classifier">int [if implot]</span></dt><dd><p>number of panels across to display.</p>
</dd>
<dt>msub<span class="classifier">bool [if implot]</span></dt><dd><p>subtract the median from each window before scaling for the
image display or not. This happens after any bias subtraction.</p>
</dd>
<dt>xlo<span class="classifier">float [if implot]</span></dt><dd><p>left-hand X-limit for plot</p>
</dd>
<dt>xhi<span class="classifier">float [if implot]</span></dt><dd><p>right-hand X-limit for plot (can actually be &lt; xlo)</p>
</dd>
<dt>ylo<span class="classifier">float [if implot]</span></dt><dd><p>lower Y-limit for plot</p>
</dd>
<dt>yhi<span class="classifier">float [if implot]</span></dt><dd><p>upper Y-limit for plot (can be &lt; ylo)</p>
</dd>
<dt>iset<span class="classifier">string [if implot]</span></dt><dd><p>determines how the intensities are determined. There are three
options: ‘a’ for automatic simply scales from the minimum to the
maximum value found on a per CCD basis. ‘d’ for direct just takes
two numbers from the user. ‘p’ for percentile dtermines levels
based upon percentiles determined from the entire CCD on a per CCD
basis.</p>
</dd>
<dt>ilo<span class="classifier">float [if implot and iset=’d’]</span></dt><dd><p>lower intensity level</p>
</dd>
<dt>ihi<span class="classifier">float [if implot and iset=’d’]</span></dt><dd><p>upper intensity level</p>
</dd>
<dt>plo<span class="classifier">float [if implot and iset=’p’]</span></dt><dd><p>lower percentile level</p>
</dd>
<dt>phi<span class="classifier">float [if implot and iset=’p’]</span></dt><dd><p>upper percentile level</p>
</dd>
</dl>
</div></blockquote>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The transmission plot generated with reduce is not reliable in the
case of optimal photometry since it is highly correlated with the
seeing. If you are worried about the transmission during observing,
you should always use normal aperture photometry.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.rtplot">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">rtplot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.rtplot" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">rtplot</span> <span class="pre">[source</span> <span class="pre">device</span> <span class="pre">width</span> <span class="pre">height]</span> <span class="pre">(run</span> <span class="pre">first</span> <span class="pre">[twait</span> <span class="pre">tmax]</span> <span class="pre">|</span>
<span class="pre">flist)</span> <span class="pre">trim</span> <span class="pre">([ncol</span> <span class="pre">nrow])</span> <span class="pre">(ccd</span> <span class="pre">(nx))</span> <span class="pre">[pause</span> <span class="pre">plotall]</span> <span class="pre">bias</span>
<span class="pre">[lowlevel</span> <span class="pre">highlevel]</span> <span class="pre">flat</span> <span class="pre">defect</span> <span class="pre">setup</span> <span class="pre">[drurl]</span> <span class="pre">msub</span> <span class="pre">iset</span> <span class="pre">(ilo</span> <span class="pre">ihi</span>
<span class="pre">|</span> <span class="pre">plo</span> <span class="pre">phi)</span> <span class="pre">xlo</span> <span class="pre">xhi</span> <span class="pre">ylo</span> <span class="pre">yhi</span> <span class="pre">(profit</span> <span class="pre">[fdevice</span> <span class="pre">fwidth</span> <span class="pre">fheight</span> <span class="pre">method</span>
<span class="pre">beta</span> <span class="pre">fwhm</span> <span class="pre">fwhm_min</span> <span class="pre">shbox</span> <span class="pre">smooth</span> <span class="pre">splot</span> <span class="pre">fhbox</span> <span class="pre">hmin</span> <span class="pre">read</span> <span class="pre">gain</span>
<span class="pre">thresh])</span></code></p>
<p>Plots a sequence of images as a movie in near ‘real time’, hence
‘rt’. Designed to be used to look at images coming in while at the
telescope, ‘rtplot’ comes with many options, a large number of
which are hidden by default, and many of which are only prompted
if other arguments are set correctly. If you want to see them all,
invoke as ‘rtplot prompt’.  This is worth doing once to know
rtplot’s capabilities.</p>
<p>rtplot can source data from both the ULTRACAM and HiPERCAM
servers, from local ‘raw’ ULTRACAM and HiPERCAM files (i.e. .xml +
.dat for ULTRACAM, 3D FITS files for HiPERCAM) and from lists of
HiPERCAM ‘.hcm’ files.</p>
<p>rtplot optionally allows the selection of targets to be fitted
with gaussian or moffat profiles, and, if successful, will plot
circles of 2x the measured FWHM in green over the selected
targets. This option only works if a single CCD is being plotted.</p>
<p>Parameters:</p>
<blockquote>
<div><dl>
<dt>source<span class="classifier">str [hidden]</span></dt><dd><p>Data source, five options:</p>
<blockquote>
<div><div class="line-block">
<div class="line">‘hs’ : HiPERCAM server</div>
<div class="line">‘hl’ : local HiPERCAM FITS file</div>
<div class="line">‘us’ : ULTRACAM server</div>
<div class="line">‘ul’ : local ULTRACAM .xml/.dat files</div>
<div class="line">‘hf’ : list of HiPERCAM hcm FITS-format files</div>
</div>
</div></blockquote>
<p>‘hf’ is used to look at sets of frames generated by ‘grab’
or converted from foreign data formats. The standard
start-off default for <code class="docutils literal notranslate"><span class="pre">source</span></code> can be set using the
environment variable HIPERCAM_DEFAULT_SOURCE. e.g. in bash
<code class="code docutils literal notranslate"><span class="pre">export</span> <span class="pre">HIPERCAM_DEFAULT_SOURCE=&quot;us&quot;</span></code> would ensure it
always started with the ULTRACAM server by default. If
unspecified, it defaults to ‘hl’.</p>
</dd>
<dt>device<span class="classifier">str [hidden]</span></dt><dd><p>Plot device. PGPLOT is used so this should be a PGPLOT-style name,
e.g. ‘/xs’, ‘1/xs’ etc. At the moment only ones ending /xs are
supported.</p>
</dd>
<dt>width<span class="classifier">float [hidden]</span></dt><dd><p>plot width (inches). Set = 0 to let the program choose.</p>
</dd>
<dt>height<span class="classifier">float [hidden]</span></dt><dd><p>plot height (inches). Set = 0 to let the program choose. BOTH width
AND height must be non-zero to have any effect</p>
</dd>
<dt>run<span class="classifier">str [if source ends ‘s’ or ‘l’]</span></dt><dd><p>run number to access, e.g. ‘run034’</p>
</dd>
<dt>flist<span class="classifier">str [if source ends ‘f’]</span></dt><dd><p>name of file list</p>
</dd>
<dt>first<span class="classifier">int [if source ends ‘s’ or ‘l’]</span></dt><dd><p>exposure number to start from. 1 = first frame; set = 0 to always
try to get the most recent frame (if it has changed).  For data
from the HiPERCAM server, a negative number tries to get a frame not
quite at the end.  i.e. -10 will try to get 10 from the last
frame. This is mainly to sidestep a difficult bug with the
acquisition system.</p>
</dd>
<dt>twait<span class="classifier">float [if source ends ‘s’ or ‘l’; hidden]</span></dt><dd><p>time to wait between attempts to find a new exposure, seconds.</p>
</dd>
<dt>tmax<span class="classifier">float [if source ends ‘s’ or ‘l’; hidden]</span></dt><dd><p>maximum time to wait between attempts to find a new exposure,
seconds.</p>
</dd>
<dt>trim<span class="classifier">bool [if source starts with ‘u’]</span></dt><dd><p>True to trim columns and/or rows off the edges of windows nearest
the readout which can sometimes contain bad data.</p>
</dd>
<dt>ncol<span class="classifier">int [if trim, hidden]</span></dt><dd><p>Number of columns to remove (on left of left-hand window, and right
of right-hand windows)</p>
</dd>
<dt>nrow<span class="classifier">int [if trim, hidden]</span></dt><dd><p>Number of rows to remove (bottom of windows)</p>
</dd>
<dt>ccd<span class="classifier">str</span></dt><dd><p>CCD(s) to plot, ‘0’ for all, ‘1 3’ to plot ‘1’ and ‘3’ only, etc.</p>
</dd>
<dt>nx<span class="classifier">int [if more than 1 CCD]</span></dt><dd><p>number of panels across to display.</p>
</dd>
<dt>pause<span class="classifier">float [hidden]</span></dt><dd><p>seconds to pause between frames (defaults to 0)</p>
</dd>
<dt>plotall<span class="classifier">bool [hidden]</span></dt><dd><p>plot all frames regardless of status (i.e. including blank frames
when nskips are enabled (defaults to False). The profile fitting
will still be disabled for bad frames.</p>
</dd>
<dt>bias<span class="classifier">str</span></dt><dd><p>Name of bias frame to subtract, ‘none’ to ignore.</p>
</dd>
<dt>lowlevel<span class="classifier">float [hidden]</span></dt><dd><p>Level below which a warning about low bias levels is warned. Set=0
to ignore. Applied to first window of first CCD. 2000 about
right for ULTRACAM.</p>
</dd>
<dt>highlevel<span class="classifier">float [hidden]</span></dt><dd><p>Level above which a warning about high bias levels is warned. Set=0
to ignore. Applied to first window of first CCD. 3500 about
right for ULTRACAM.</p>
</dd>
<dt>flat<span class="classifier">str</span></dt><dd><p>Name of flat field to divide by, ‘none’ to ignore. Should normally
only be used in conjunction with a bias, although it does allow you
to specify a flat even if you haven’t specified a bias.</p>
</dd>
<dt>defect<span class="classifier">str</span></dt><dd><p>Name of defect file, ‘none’ to ignore.</p>
</dd>
<dt>setup<span class="classifier">bool</span></dt><dd><p>True/yes to access the current windows from hdriver. Useful
during observing when seeting up windows, but not normally
otherwise. Next argument (hidden) is the URL to get to
hdriver. Once setup, you should probably turn this off to
avoid overloading hdriver, especially if in drift mode as
it makes a request for the windows for every frame.</p>
</dd>
<dt>drurl<span class="classifier">str [if setup; hidden]</span></dt><dd><p>URL needed to access window setting from the camera
driver (ultracam, ultraspec, hipercam). The internal server 
in the camera driver must be switched on which can be done
from the GUI.</p>
</dd>
<dt>msub<span class="classifier">bool</span></dt><dd><p>subtract the median from each window before scaling for the
image display or not. This happens after any bias subtraction.</p>
</dd>
<dt>iset<span class="classifier">str [single character]</span></dt><dd><p>determines how the intensities are determined. There are three
options: ‘a’ for automatic simply scales from the minimum to the
maximum value found on a per CCD basis. ‘d’ for direct just takes
two numbers from the user. ‘p’ for percentile dtermines levels
based upon percentiles determined from the entire CCD on a per CCD
basis.</p>
</dd>
<dt>ilo<span class="classifier">float [if iset=’d’]</span></dt><dd><p>lower intensity level</p>
</dd>
<dt>ihi<span class="classifier">float [if iset=’d’]</span></dt><dd><p>upper intensity level</p>
</dd>
<dt>plo<span class="classifier">float [if iset=’p’]</span></dt><dd><p>lower percentile level</p>
</dd>
<dt>phi<span class="classifier">float [if iset=’p’]</span></dt><dd><p>upper percentile level</p>
</dd>
<dt>xlo<span class="classifier">float</span></dt><dd><p>left-hand X-limit for plot</p>
</dd>
<dt>xhi<span class="classifier">float</span></dt><dd><p>right-hand X-limit for plot (can actually be &lt; xlo)</p>
</dd>
<dt>ylo<span class="classifier">float</span></dt><dd><p>lower Y-limit for plot</p>
</dd>
<dt>yhi<span class="classifier">float</span></dt><dd><p>upper Y-limit for plot (can be &lt; ylo)</p>
</dd>
<dt>profit<span class="classifier">bool [if plotting a single CCD only]</span></dt><dd><p>carry out profile fits or not. If you say yes, then on the first
plot, you will have the option to pick objects with a cursor. The
program will then attempt to track these from frame to frame, and
fit their profile. You may need to adjust ‘first’ to see anything.
The parameters used for profile fits are hidden and you may want to
invoke the command with ‘prompt’ the first time you try profile
fitting.</p>
</dd>
<dt>fdevice<span class="classifier">str [if profit; hidden]</span></dt><dd><p>plot device for profile fits, PGPLOT-style name.
e.g. ‘/xs’, ‘2/xs’ etc.</p>
</dd>
<dt>fwidth<span class="classifier">float [if profit; hidden]</span></dt><dd><p>fit plot width (inches). Set = 0 to let the program choose.</p>
</dd>
<dt>fheight<span class="classifier">float [if profit; hidden]</span></dt><dd><p>fit plot height (inches). Set = 0 to let the program choose.
BOTH fwidth AND fheight must be non-zero to have any effect</p>
</dd>
<dt>method<span class="classifier">str [if profit; hidden]</span></dt><dd><p>this defines the profile fitting method, either a gaussian or a
moffat profile. The latter is usually best.</p>
</dd>
<dt>beta<span class="classifier">float [if profit and method == ‘m’; hidden]</span></dt><dd><p>default Moffat exponent</p>
</dd>
<dt>fwhm<span class="classifier">float [if profit; hidden]</span></dt><dd><p>default FWHM, unbinned pixels.</p>
</dd>
<dt>fwhm_min<span class="classifier">float [if profit; hidden]</span></dt><dd><p>minimum FWHM to allow, unbinned pixels.</p>
</dd>
<dt>shbox<span class="classifier">float [if profit; hidden]</span></dt><dd><p>half width of box for searching for a star, unbinned pixels. The
brightest target in a region +/- shbox around an intial position
will be found. ‘shbox’ should be large enough to allow for likely
changes in position from frame to frame, but try to keep it as
small as you can to avoid jumping to different targets and to
reduce the chances of interference by cosmic rays.</p>
</dd>
<dt>smooth<span class="classifier">float [if profit; hidden]</span></dt><dd><p>FWHM for gaussian smoothing, binned pixels. The initial position
for fitting is determined by finding the maximum flux in a smoothed
version of the image in a box of width +/- shbox around the starter
position. Typically should be comparable to the stellar width. Its
main purpose is to combat cosmi rays which tend only to occupy a
single pixel.</p>
</dd>
<dt>splot<span class="classifier">bool [if profit; hidden]</span></dt><dd><p>Controls whether an outline of the search box and a target number
is plotted (in red) or not.</p>
</dd>
<dt>fhbox<span class="classifier">float [if profit; hidden]</span></dt><dd><p>half width of box for profile fit, unbinned pixels. The fit box is
centred on the position located by the initial search. It should
normally be &gt; ~2x the expected FWHM.</p>
</dd>
<dt>hmin<span class="classifier">float [if profit; hidden]</span></dt><dd><p>height threshold to accept a fit. If the height is below this
value, the position will not be updated. This is to help in cloudy
conditions.</p>
</dd>
<dt>read<span class="classifier">float [if profit; hidden]</span></dt><dd><p>readout noise, RMS ADU, for assigning uncertainties</p>
</dd>
<dt>gain<span class="classifier">float [if profit; hidden]</span></dt><dd><p>gain, ADU/count, for assigning uncertainties</p>
</dd>
<dt>thresh<span class="classifier">float [if profit; hidden]</span></dt><dd><p>sigma rejection threshold for fits</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.rupdate">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">rupdate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.rupdate" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">rupdate</span> <span class="pre">rfile</span></code></p>
<p>As changes are made to ‘reduce’, old reduce files can become
obsolete. This script tries to bring old reduce files up to date
by adding in the new options but in a way that should give the old
behaviour. The file is modified in place.</p>
<p>There are some cases where a full update might not be possible and
a further manual edit of the reduce file might be required.</p>
<p>Parameters:</p>
<blockquote>
<div><dl class="simple">
<dt>rfile<span class="classifier">string</span></dt><dd><p>the output reduce file created using <a class="reference internal" href="#hipercam.scripts.setaper" title="hipercam.scripts.setaper"><code class="xref py py-func docutils literal notranslate"><span class="pre">setaper</span></code></a>. This will be read
for the targets. The main target will be assumed to have been
called ‘1’, the main comparison ‘2’. If there is a ‘3’ it will be
plotted relative to ‘2’; all others will be ignored for plotting
purposes.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.setaper">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">setaper</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.setaper" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">setaper</span> <span class="pre">mccd</span> <span class="pre">aper</span> <span class="pre">ccd</span> <span class="pre">[linput</span> <span class="pre">width</span> <span class="pre">height]</span> <span class="pre">rtarg</span> <span class="pre">rsky1</span> <span class="pre">rsky2</span> <span class="pre">xlo</span>
<span class="pre">xhi</span> <span class="pre">ylo</span> <span class="pre">yhi</span> <span class="pre">nx</span> <span class="pre">msub</span> <span class="pre">[cmap]</span> <span class="pre">iset</span> <span class="pre">(ilo</span> <span class="pre">ihi</span> <span class="pre">|</span> <span class="pre">plo</span> <span class="pre">phi)</span> <span class="pre">[profit</span> <span class="pre">method</span> <span class="pre">(beta</span>
<span class="pre">betafix</span> <span class="pre">betamax)</span> <span class="pre">fwhm</span> <span class="pre">fwfix</span> <span class="pre">(fwmin)</span> <span class="pre">shbox</span> <span class="pre">smooth</span> <span class="pre">splot</span> <span class="pre">fhbox</span> <span class="pre">read</span>
<span class="pre">gain</span> <span class="pre">thresh]</span></code></p>
<p>Interactive definition of photometric extraction apertures. This
is a matplotlib-based routine allowing you to place apertures on
targets using the cursor. It is an essential prerequisite to
running <a class="reference internal" href="#hipercam.scripts.reduce" title="hipercam.scripts.reduce"><code class="xref py py-func docutils literal notranslate"><span class="pre">reduce</span></code></a>.  You are advised at the minimum to have
subtracted the bias from the frame of interest since that makes
the assignment of uncertainties to the data used when making
profile fits much more reliable.</p>
<p>Parameters:</p>
<blockquote>
<div><dl class="simple">
<dt>mccd<span class="classifier">string</span></dt><dd><p>name of an MCCD file, as produced by e.g. ‘grab’</p>
</dd>
<dt>aper<span class="classifier">string</span></dt><dd><p>the name of an aperture file. If it exists it will be read so that
apertures can be added to it. If it does not exist, it will be
created on exiting the routine. The aperture files are is a fairly
readable / editiable text format</p>
</dd>
<dt>ccd<span class="classifier">string</span></dt><dd><p>CCD(s) to plot, ‘0’ for all. If not ‘0’ then ‘1’, ‘2’ or even ‘3 4’
are possible inputs (without the quotes). ‘3 4’ will plot CCD ‘3’ and
CCD ‘4’. If you want to plot more than one CCD, then you will be
prompted for the number of panels in the X direction. This parameter
will not be prompted if there is only one CCD in the file.</p>
</dd>
<dt>linput<span class="classifier">string [hidden]</span></dt><dd><p>sets the way in which the apertures are labelled. ‘n’ = numerical
input, with the program just incrementing by 1 for each successive
aperture; ‘s’ = single character (without requiring the user to hit
hit &lt;CR&gt;); ‘m’ = multi-character, ending with &lt;CR&gt;.
Allowed characters are 0-9, a-z, A-Z, no spaces or punctuation, but a
single ‘0’ on its own is not permitted.</p>
</dd>
<dt>width<span class="classifier">float [hidden]</span></dt><dd><p>plot width (inches). Set = 0 to let the program choose.</p>
</dd>
<dt>height<span class="classifier">float [hidden]</span></dt><dd><p>plot height (inches). Set = 0 to let the program choose. BOTH width
AND height must be non-zero to have any effect</p>
</dd>
<dt>rtarg<span class="classifier">float [unbinned pixels]</span></dt><dd><p>radius of target aperture. The exact value of this does not matter
too much since it is normally overridden in ‘reduce’, but typically
one aims for 1.5 to 2.5 x FWHM, seeing, depending upon the target
brightness.</p>
</dd>
<dt>rsky1<span class="classifier">float [unbinned pixels]</span></dt><dd><p>inner radius of sky aperture.</p>
</dd>
<dt>rsky2<span class="classifier">float [unbinned pixels]</span></dt><dd><p>radius of target aperture</p>
</dd>
<dt>xlo<span class="classifier">float</span></dt><dd><p>left X-limit to restrict region used to compute percentile
limits. This allows you to only consider useful data if for
example there are bias strips, and makes setting the percentile
limits less fiddly.</p>
</dd>
<dt>xhi<span class="classifier">float</span></dt><dd><p>right X-limit. See comments for xlo as well.</p>
</dd>
<dt>ylo<span class="classifier">float</span></dt><dd><p>bottom Y-limit. See comments for xlo as well.</p>
</dd>
<dt>yhi<span class="classifier">float</span></dt><dd><p>top Y-limit. See comments for xlo as well.</p>
</dd>
<dt>nx<span class="classifier">int</span></dt><dd><p>number of panels across to display, prompted if more than one CCD is
to be plotted.</p>
</dd>
<dt>msub<span class="classifier">bool</span></dt><dd><p>True/False to subtract median from each window before scaling</p>
</dd>
<dt>cmap<span class="classifier">str [hidden]</span></dt><dd><p>Colour map to use. “Greys” is usual greyscale. “none” to get matplotlib
default.</p>
</dd>
<dt>iset<span class="classifier">string [single character]</span></dt><dd><p>determines how the intensities are determined. There are three
options: ‘a’ for automatic simply scales from the minimum to the
maximum value found on a per CCD basis. ‘d’ for direct just takes two
numbers from the user. ‘p’ for percentile dtermines levels based upon
percentiles determined from the entire CCD on a per CCD bais.</p>
</dd>
<dt>ilo<span class="classifier">float [if iset==’d’]</span></dt><dd><p>lower intensity level</p>
</dd>
<dt>ihi<span class="classifier">float [if iset==’d’]</span></dt><dd><p>upper intensity level</p>
</dd>
<dt>plo<span class="classifier">float [if iset==’p’]</span></dt><dd><p>lower percentile level</p>
</dd>
<dt>phi<span class="classifier">float [if iset==’p’]</span></dt><dd><p>upper percentile level</p>
</dd>
<dt>profit<span class="classifier">bool [hidden]</span></dt><dd><p>start aperture selection with profile fitting-based position
refinement (or not). Can be toggled at any point.</p>
</dd>
<dt>method<span class="classifier">string [hidden]</span></dt><dd><p>this defines the profile fitting method, if profile fitting is used
to refine the aperture position. Either a gaussian or a moffat
profile, ‘g’ or ‘m’.  The latter should usually be best.</p>
</dd>
<dt>beta<span class="classifier">float [if method == ‘m’; hidden]</span></dt><dd><p>default Moffat exponent</p>
</dd>
<dt>betafix<span class="classifier">bool [if method == ‘m’; hidden]</span></dt><dd><p>fix beta or not</p>
</dd>
<dt>beta_max<span class="classifier">bool [if method == ‘m’ and not betafix; hidden]</span></dt><dd><p>maximum value of beta. Moffat profiles are degenerate
with gaussians at large beta so the idea is to avoid wandering
to huge beta.</p>
</dd>
<dt>fwhm<span class="classifier">float [hidden]</span></dt><dd><p>default FWHM, unbinned pixels. It helps to get this of the right order of
mag at the start; too large is better than too small.</p>
</dd>
<dt>fwfix: bool [hidden]</dt><dd><p>don’t fit the FWHM. Can be more robust; the position is still fitted.</p>
</dd>
<dt>fwmin<span class="classifier">float [if not fwfix; hidden]</span></dt><dd><p>minimum FWHM to allow, unbinned pixels.</p>
</dd>
<dt>shbox<span class="classifier">float [hidden]</span></dt><dd><p>half width of box for searching for a star, unbinned pixels. The
brightest target in a region +/- shbox around an intial position will
be found. ‘shbox’ should be large enough to allow for likely changes
in position from frame to frame, but try to keep it as small as you
can to avoid jumping to different targets and to reduce the chances
of interference by cosmic rays.</p>
</dd>
<dt>smooth<span class="classifier">float [hidden]</span></dt><dd><p>FWHM for gaussian smoothing, binned pixels. The initial position for
fitting is determined by finding the maximum flux in a smoothed
version of the image in a box of width +/- shbox around the starter
position. Typically should be comparable to the stellar width. Its
main purpose is to combat cosmic rays which tend only to occupy a
single pixel.</p>
</dd>
<dt>splot<span class="classifier">bool [hidden]</span></dt><dd><p>Controls whether an outline of the search box and a target number
is plotted (in red) or not.</p>
</dd>
<dt>fhbox<span class="classifier">float [hidden]</span></dt><dd><p>half width of box for profile fit, unbinned pixels. The fit box is
centred on the position located by the initial search. It should
normally be &gt; ~2x the expected FWHM.</p>
</dd>
<dt>read<span class="classifier">float [hidden]</span></dt><dd><p>readout noise, RMS ADU, for assigning uncertainties</p>
</dd>
<dt>gain<span class="classifier">float [hidden]</span></dt><dd><p>gain, ADU/count, for assigning uncertainties</p>
</dd>
<dt>thresh<span class="classifier">float [hidden]</span></dt><dd><p>thresh rejection threshold. Be careful. Bad combinations of this
and the initial FWHM can cause wholessale rejection of good pixels,
so don’t be overzealous.</p>
</dd>
<dt>ndiv<span class="classifier">int [hidden]</span></dt><dd><p>sub-division factor for fits. 0=no sub-division. Otherwise it will used
ndiv*ndiv sub-evaluations per <em>unbinned</em> pixel</p>
</dd>
</dl>
</div></blockquote>
<p>There are a few conveniences to make setaper easier:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The plot is initialised in pan mode whereby you can move around and
scale using the left and right mouse buttons.</p></li>
<li><p>All input is accomplished with the keyboard; the mouse buttons are
only for navigating the image.</p></li>
<li><p>The label input can be switched between sequential numerical,
single- and multi-character input (‘linput’).</p></li>
</ol>
</div></blockquote>
<p>Various standard keyboard shortcuts (e.g. ‘s’ to save) are disabled as
they just confuse things and are of limited use in setaper in any case.</p>
<p>Some aspects of the usage of matplotlib in setaper are tricky. It is
possible that particular ‘backends’ will cause problems. I have tested
this with Qt4Agg, Qt5agg and GTK3Agg. One aspect is the cursor icon in pan
mode is a rather indistinct hand where one can’t tell what is being
pointed at. I have therefore suppressed this, but only for the tested
backends. Others would need require further investigation.</p>
<p>When in <cite>setaper</cite>, help is always available by hitting ‘h’. Most of the
options are self-evident. A few which may not be are:</p>
<blockquote>
<div><div class="line-block">
<div class="line">e(xtra)    : add extra pixels to the target aperture. This allows you</div>
<div class="line-block">
<div class="line">to sculpt the shape of the extraction aperure to perhaps</div>
<div class="line">include the flux of a blended star.</div>
<div class="line"><br /></div>
</div>
<div class="line">l(ink)     : link one aperture to another in the same CCD for</div>
<div class="line-block">
<div class="line">re-positioning. If a target is very faint or will</div>
<div class="line">disappear, this will make sure that its position</div>
<div class="line">is defined relative to another, brighter star. Best</div>
<div class="line">to choose one close by because of potential refractive</div>
<div class="line">distortion.</div>
<div class="line"><br /></div>
</div>
<div class="line">r(eference): toggle whether an aperture is a reference aperture. The</div>
<div class="line-block">
<div class="line">re-positioning can work in two steps: first position</div>
<div class="line">reference stars, then the other stars, using the reference</div>
<div class="line">stars to provide a first cut at the position shift of the</div>
<div class="line">rest.</div>
<div class="line"><br /></div>
</div>
<div class="line">i(njected) : toggle whether an aperture is a COMPO aperture and has</div>
<div class="line-block">
<div class="line">been injected. These apertures move differently on the</div>
<div class="line">CCD from non-injected apertures and need to be labelled</div>
<div class="line">so that aperture positioning can be done correctly.</div>
<div class="line"><br /></div>
</div>
<div class="line">C(opy)     : copy apertures of the CCD the cursor is in to all others.</div>
<div class="line-block">
<div class="line">This basically clones apertures across the CCDs. You will</div>
<div class="line">need to re-centre each on afterwards.</div>
</div>
</div>
</div></blockquote>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The aperture positions immediately after a copy reflect the origin CCD,
and may be somewhat off if there are significant offsets between CCDs.</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.setdefect">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">setdefect</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.setdefect" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">setdefect</span> <span class="pre">mccd</span> <span class="pre">defect</span> <span class="pre">ccd</span> <span class="pre">[width</span> <span class="pre">height]</span> <span class="pre">nx</span> <span class="pre">msub</span> <span class="pre">[cmap]</span> <span class="pre">ffield</span>
<span class="pre">(auto</span> <span class="pre">(hlo</span> <span class="pre">hhi</span> <span class="pre">severity))</span> <span class="pre">hsbox</span> <span class="pre">iset</span> <span class="pre">(ilo</span> <span class="pre">ihi</span> <span class="pre">|</span> <span class="pre">plo</span> <span class="pre">phi)</span></code></p>
<p>Interactive definition of CCD defects. This is a matplotlib-based routine
allowing you to define defects using the cursor. Various routines allow
you to overplot defects, above all <a class="reference internal" href="#hipercam.scripts.rtplot" title="hipercam.scripts.rtplot"><code class="xref py py-func docutils literal notranslate"><span class="pre">rtplot</span></code></a> / <a class="reference internal" href="#hipercam.scripts.nrtplot" title="hipercam.scripts.nrtplot"><code class="xref py py-func docutils literal notranslate"><span class="pre">nrtplot</span></code></a>. Point-like and
line-like defects of two different colours (orange for moderate, red for
severe can be marked). Hot pixels can be marked by their count rate as
measured in dark frames.</p>
<p>You should apply this in stages using bias frames and flat fields
to set the point and line defects, and a darkframe from <a class="reference internal" href="#hipercam.scripts.makedark" title="hipercam.scripts.makedark"><code class="xref py py-func docutils literal notranslate"><span class="pre">makedark</span></code></a>
to set hot pixels. The latter can be set semi-automatically by
flagging pixels between pre-set rate values.</p>
<p>Parameters:</p>
<blockquote>
<div><dl class="simple">
<dt>mccd<span class="classifier">str</span></dt><dd><p>name of an MCCD file, as produced by e.g. ‘grab’</p>
</dd>
<dt>defect<span class="classifier">str</span></dt><dd><p>the name of a defect file. If it exists it will be read so that
defects can be added to it. If it does not exist, it will be
created on exiting the routine. The defect files are in a fairly
readable / editiable text format</p>
</dd>
<dt>ccd<span class="classifier">str</span></dt><dd><p>CCD(s) to plot, ‘0’ for all. If not ‘0’ then ‘1’, ‘2’ or even ‘3 4’
are possible inputs (without the quotes). ‘3 4’ will plot CCD ‘3’ and
CCD ‘4’. If you want to plot more than one CCD, then you will be
prompted for the number of panels in the X direction. This parameter
will not be prompted if there is only one CCD in the file.</p>
</dd>
<dt>width<span class="classifier">float [hidden]</span></dt><dd><p>plot width (inches). Set = 0 to let the program choose.</p>
</dd>
<dt>height<span class="classifier">float [hidden]</span></dt><dd><p>plot height (inches). Set = 0 to let the program choose. BOTH width
AND height must be non-zero to have any effect</p>
</dd>
<dt>nx<span class="classifier">int</span></dt><dd><p>number of panels across to display, prompted if more than one CCD is
to be plotted.</p>
</dd>
<dt>msub<span class="classifier">bool</span></dt><dd><p>True/False to subtract median from each window before scaling</p>
</dd>
<dt>cmap<span class="classifier">str [hidden]</span></dt><dd><p>The colour map to use. “Greys” is the usual; “Greys_r” reverses it.
There are many others; typing an incorrect one will give a list. “none”
for matplotlib default.</p>
</dd>
<dt>ffield<span class="classifier">bool</span></dt><dd><p>If True, all defects will be assumed to be flat-field or poor
charge transfer defects as opposed to hot pixels. The latter
should be set from dark frames, and have a different impact
than the first two types in that they are worst for faint
targets. Hot pixels and flat-field defects are shown with the
same colours for moderate and severe, but different symbols
(filled circles for flat-field defects, stars for hot
pixels). If you say “no” in order to add hot pixels, the line
defect option is not available.</p>
</dd>
<dt>auto<span class="classifier">bool [if ffield==False]</span></dt><dd><p>Hot pixels can be set automatically if wanted. If so then a
few extra parameters are needed. This only makes sense if you
are feeding setdefect with a dark frame produced by
<a class="reference internal" href="#hipercam.scripts.makedark" title="hipercam.scripts.makedark"><code class="xref py py-func docutils literal notranslate"><span class="pre">makedark</span></code></a> so that the intensity levels mean something.</p>
</dd>
<dt>hlo<span class="classifier">float [if auto]</span></dt><dd><p>lower limit to flag as a hot pixel as a count rate per second</p>
</dd>
<dt>hhi<span class="classifier">float [if auto]</span></dt><dd><p>upper limit to flag as a hot pixel as a count rate per second</p>
</dd>
<dt>severity<span class="classifier">str [if auto]</span></dt><dd><p>‘m’ for moderate, ‘n’ for nasty. Controls colour used to plot
the hot pixel; it will be labelled with a rate as well.</p>
</dd>
<dt>hsbox<span class="classifier">int</span></dt><dd><p>half-width in binned pixels of stats box as offset from central pixel
hsbox = 1 gives a 3x3 box; hsbox = 2 gives 5x5 etc. This is used by
the “show” option when setting defects.</p>
</dd>
<dt>iset<span class="classifier">str [single character]</span></dt><dd><p>determines how the intensities are determined. There are three
options: ‘a’ for automatic simply scales from the minimum to the
maximum value found on a per CCD basis. ‘d’ for direct just takes two
numbers from the user. ‘p’ for percentile dtermines levels based upon
percentiles determined from the entire CCD on a per CCD bais.</p>
</dd>
<dt>ilo<span class="classifier">float [if iset==’d’]</span></dt><dd><p>lower intensity level</p>
</dd>
<dt>ihi<span class="classifier">float [if iset==’d’]</span></dt><dd><p>upper intensity level</p>
</dd>
<dt>plo<span class="classifier">float [if iset==’p’]</span></dt><dd><p>lower percentile level</p>
</dd>
<dt>phi<span class="classifier">float [if iset==’p’]</span></dt><dd><p>upper percentile level</p>
</dd>
</dl>
</div></blockquote>
<p>There are a few conveniences to make setdefect easier:</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>The plot is initialised in pan mode whereby you can move around and
scale using the left and right mouse buttons.</p></li>
<li><p>All input is accomplished with the keyboard; the mouse buttons are
only for navigating the image.</p></li>
<li><p>The label input can be switched between sequential numerical,
single- and multi-character input (‘linput’).</p></li>
</ol>
</div></blockquote>
<p>Various standard keyboard shortcuts (e.g. ‘s’ to save) are disabled as
they just confuse things and are of limited use in setdefect in any case.</p>
<p>Some aspects of the usage of matplotlib in setdefect are tricky. It is
possible that particular ‘backends’ will cause problems. I have tested
this with Qt4Agg, Qt5agg and GTK3Agg. One aspect is the cursor icon in pan
mode is a rather indistinct hand where one can’t tell what is being
pointed at. I have therefore suppressed this, but only for the tested
backends. Others would need require further investigation.</p>
<p>NB At the end of this routine, it re-orders the defects so that the severe
ones follows the moderates. This helps emphasize the severe ones over the
moderates when running rtplot.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.setfringe">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">setfringe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.setfringe" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">setfringe</span> <span class="pre">fmap</span> <span class="pre">fringe</span> <span class="pre">ccd</span> <span class="pre">[width</span> <span class="pre">height]</span> <span class="pre">nx</span> <span class="pre">[cmap</span> <span class="pre">nhalf]</span> <span class="pre">iset</span> <span class="pre">(ilo</span> <span class="pre">ihi</span>
<span class="pre">|</span> <span class="pre">plo</span> <span class="pre">phi)</span></code></p>
<p>Interactive definition of CCD fringe pairs. The idea is to place a large
number of such pairs at the peaks and valleys of a fringe map file. To
defringe a file, the differences of intensity for each pair will be evaluated
in the data and the fringe map and the ratio of these differences taken. The
median of these ratios will be used to scale the fringe map which will then be
subtracted. The use of a median allows the odd ratio to be ruined by stars,
as long as a large number of pairs are defined.</p>
<p>Parameters:</p>
<blockquote>
<div><dl class="simple">
<dt>fmap<span class="classifier">str</span></dt><dd><p>name of an MCCD file showing fringes with objects removed, e.g.
as produced by ‘makefringe’</p>
</dd>
<dt>fringe<span class="classifier">str</span></dt><dd><p>the name of a file of fringe pairs. If it exists it will be
read so that more fringe pairs can be added to it. If it does
not exist, it will be created on exiting the routine. The
files are in a fairly readable / editable text format</p>
</dd>
<dt>ccd<span class="classifier">str</span></dt><dd><p>CCD(s) to plot, ‘0’ for all. If not ‘0’ then ‘1’, ‘2’ or even ‘3 4’
are possible inputs (without the quotes). ‘3 4’ will plot CCD ‘3’ and
CCD ‘4’. If you want to plot more than one CCD, then you will be
prompted for the number of panels in the X direction. This parameter
will not be prompted if there is only one CCD in the file.</p>
</dd>
<dt>width<span class="classifier">float [hidden]</span></dt><dd><p>plot width (inches). Set = 0 to let the program choose.</p>
</dd>
<dt>height<span class="classifier">float [hidden]</span></dt><dd><p>plot height (inches). Set = 0 to let the program choose. BOTH width
AND height must be non-zero to have any effect</p>
</dd>
<dt>nx<span class="classifier">int</span></dt><dd><p>number of panels across to display, prompted if more than one CCD is
to be plotted.</p>
</dd>
<dt>cmap<span class="classifier">str [hidden]</span></dt><dd><p>The colour map to use. “Greys” is the usual; “Greys_r” reverses it.
There are many others; typing an incorrect one will give a list. “none”
for matplotlib default.</p>
</dd>
<dt>nhalf<span class="classifier">int [hidden]</span></dt><dd><p>half-width in binned pixels of stats box as offset from central pixel
nhalf = 1 gives a 3x3 box; hsbox = 2 gives 5x5 etc. This is used by
the “show” option when setting FringePair and when reporting FringePair
differences.</p>
</dd>
<dt>iset<span class="classifier">str [single character]</span></dt><dd><p>determines how the intensities are determined. There are three
options: ‘a’ for automatic simply scales from the minimum to the
maximum value found on a per CCD basis. ‘d’ for direct just takes two
numbers from the user. ‘p’ for percentile dtermines levels based upon
percentiles determined from the entire CCD on a per CCD bais.</p>
</dd>
<dt>ilo<span class="classifier">float [if iset==’d’]</span></dt><dd><p>lower intensity level</p>
</dd>
<dt>ihi<span class="classifier">float [if iset==’d’]</span></dt><dd><p>upper intensity level</p>
</dd>
<dt>plo<span class="classifier">float [if iset==’p’]</span></dt><dd><p>lower percentile level</p>
</dd>
<dt>phi<span class="classifier">float [if iset==’p’]</span></dt><dd><p>upper percentile level</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.shiftadd">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">shiftadd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.shiftadd" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">shiftadd</span> <span class="pre">[source]</span>&#160; <span class="pre">(run</span> <span class="pre">first</span> <span class="pre">last</span> <span class="pre">twait</span> <span class="pre">tmax</span> <span class="pre">|</span> <span class="pre">flist)</span> <span class="pre">rfilen</span> <span class="pre">refccd</span>
<span class="pre">fthresh</span> <span class="pre">reprmethod</span> <span class="pre">[(reprorder</span> <span class="pre">|</span> <span class="pre">consflux</span> <span class="pre">reprkernel</span> <span class="pre">kwidth</span> <span class="pre">regwidth)]</span>
<span class="pre">trim</span> <span class="pre">([ncol</span> <span class="pre">nrow])</span> <span class="pre">method</span> <span class="pre">[(sigma</span> <span class="pre">maxiters)]</span> <span class="pre">[overwrite]</span> <span class="pre">output</span></code></p>
<p>Averages images from a run using mean combination, but shifting each
image based on the positions of stars.</p>
<p>Parameters:</p>
<blockquote>
<div><dl>
<dt>source<span class="classifier">str [hidden]</span></dt><dd><p>Data source, five options:</p>
<blockquote>
<div><div class="line-block">
<div class="line">‘hs’ : HiPERCAM server</div>
<div class="line">‘hl’ : local HiPERCAM FITS file</div>
<div class="line">‘us’ : ULTRACAM server</div>
<div class="line">‘ul’ : local ULTRACAM .xml/.dat files</div>
<div class="line">‘hf’ : list of HiPERCAM hcm FITS-format files</div>
</div>
</div></blockquote>
<p>‘hf’ is used to look at sets of frames generated by ‘grab’
or converted from foreign data formats. The standard
start-off default for <code class="docutils literal notranslate"><span class="pre">source</span></code> can be set using the
environment variable HIPERCAM_DEFAULT_SOURCE. e.g. in bash
<code class="code docutils literal notranslate"><span class="pre">export</span> <span class="pre">HIPERCAM_DEFAULT_SOURCE=&quot;us&quot;</span></code> would ensure it
always started with the ULTRACAM server by default. If
unspecified, it defaults to ‘hl’.</p>
</dd>
<dt>run<span class="classifier">str [if source ends ‘s’ or ‘l’]</span></dt><dd><p>run number to access, e.g. ‘run034’</p>
</dd>
<dt>flist<span class="classifier">str [if source ends ‘f’]</span></dt><dd><p>name of file list</p>
</dd>
<dt>first<span class="classifier">int [if source ends ‘s’ or ‘l’]</span></dt><dd><p>exposure number to start from. 1 = first frame (‘0’ is
not supported).</p>
</dd>
<dt>last<span class="classifier">int [if source ends ‘s’ or ‘l’]</span></dt><dd><p>last exposure number must be &gt;= first, or 0 for the lot</p>
</dd>
<dt>twait<span class="classifier">float [if source ends ‘s’ or ‘l’; hidden]</span></dt><dd><p>time to wait between attempts to find a new exposure, seconds.</p>
</dd>
<dt>tmax<span class="classifier">float [if source ends ‘s’ or ‘l’; hidden]</span></dt><dd><p>maximum time to wait between attempts to find a new exposure,
seconds.</p>
</dd>
<dt>rfilen<span class="classifier">str</span></dt><dd><p>name of reduce file.</p>
</dd>
<dt>refccd<span class="classifier">str</span></dt><dd><p>reference CCD to use for finding offsets</p>
</dd>
<dt>fthresh<span class="classifier">float</span></dt><dd><p>maximum FWHM to allow, in unbinned pixels on the reference CCD.
frames with FWHM &gt; fthresh will be ignored.</p>
</dd>
<dt>reprmethod<span class="classifier">str</span></dt><dd><p>Method to use for reprojecting the data, three options:</p>
<blockquote>
<div><div class="line-block">
<div class="line">‘interp’: the fastest, but does not conserve flux</div>
<div class="line">‘adaptive’: slower, but conserves flux</div>
<div class="line">‘exact’: the slowest but most accurate, only available
if the input data contains WCS info (currently HiPERCAM only)</div>
</div>
</div></blockquote>
<p>The default is ‘adaptive’.
See <a class="reference external" href="https://reproject.readthedocs.io">https://reproject.readthedocs.io</a> for details.</p>
</dd>
<dt>reprorder<span class="classifier">int [if reprmethod is ‘interp’; hidden]</span></dt><dd><p>Order of interpolation to use. 0 is nearest neighbour, 1 is
bilinear, 2 is quadratic, 3 is cubic. 1 is the default.</p>
</dd>
<dt>consflux<span class="classifier">bool [if reprmethod is ‘adaptive’; hidden]</span></dt><dd><p>conserve flux when reprojecting. True is the default.</p>
</dd>
<dt>reprkernel<span class="classifier">str [if reprmethod is ‘adaptive’; hidden]</span></dt><dd><p>The averaging kernel to use. Allowed values are ‘Hann’ and ‘Gaussian’.
The Gaussian kernel produces better photometric accuracy and stronger
anti-aliasing at the cost of some blurring (on the scale of a few
pixels). If not specified, the Gaussain kernel is used by default.</p>
</dd>
<dt>kwidth<span class="classifier">float [if reprmethod is ‘adaptive’; hidden]</span></dt><dd><p>The width of the kernel in pixels, expressed as the standard
deviation of the Gaussian kernel. Is not used for the Hann kernel.
Reducing this width may introduce photometric errors or leave input
pixels under-sampled, while increasing it may improve the degree of
anti-aliasing but will increase blurring of the output image.
If this width is changed from the default, a proportional change
should be made to the value of regwidth to maintain an
equivalent degree of photometric accuracy. Default is 1.3.</p>
</dd>
<dt>regwidth<span class="classifier">float [if reprmethod is ‘adaptive’; hidden]</span></dt><dd><p>The width in pixels of the output-image region which, when
transformed to the input plane, defines the region to be sampled
for each output pixel.  Used only for the Gaussian kernel, which
otherwise has infinite extent. This value sets a trade-off between
accuracy and computation time, with better accuracy at higher values.
The default value of 4, with the default kernel width,
should limit the most extreme errors to less than one percent.
Higher values will offer even more photometric accuracy.</p>
</dd>
<dt>trim<span class="classifier">bool</span></dt><dd><p>True to trim columns and/or rows off the edges of windows nearest
the readout. Useful for ULTRACAM particularly.</p>
</dd>
<dt>ncol<span class="classifier">int [if trim, hidden]</span></dt><dd><p>Number of columns to remove (on left of left-hand window, and right
of right-hand windows)</p>
</dd>
<dt>nrow<span class="classifier">int [if trim, hidden]</span></dt><dd><p>Number of rows to remove (bottom of windows)</p>
</dd>
<dt>method<span class="classifier">str [hidden, defaults to ‘m’]</span></dt><dd><p>‘m’ for median, ‘c’ for clipped mean.</p>
</dd>
<dt>sigma<span class="classifier">float [hidden; if method == ‘c’]</span></dt><dd><p>With clipped mean combination, pixels that deviate by more than
sigma RMS from the mean are kicked out. This is carried out in an
iterative manner. sigma &lt;= 0 implies no rejection, just a straight
average. sigma=3 is typical.</p>
</dd>
<dt>maxiters<span class="classifier">int [hidden; if method == ‘c’]</span></dt><dd><p>Maximum number of iterations in sigma clipping. 3 is typical.</p>
</dd>
<dt>overwrite<span class="classifier">bool [hidden]</span></dt><dd><p>overwrite any pre-existing output files</p>
</dd>
<dt>output<span class="classifier">string</span></dt><dd><p>output file</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.splice">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">splice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.splice" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">splice</span> <span class="pre">input1</span> <span class="pre">input2</span> <span class="pre">ccd</span> <span class="pre">[win]</span> <span class="pre">output</span></code></p>
<p>Merges two multi-CCD images so that parts of input1 are replaced
by equivalent parts of input2. This can be useful e.g. to create
a combined flat field out of different frames.</p>
<p>Parameters:</p>
<blockquote>
<div><dl class="simple">
<dt>input1<span class="classifier">str</span></dt><dd><p>first input frame</p>
</dd>
<dt>input2<span class="classifier">str</span></dt><dd><p>second input frame</p>
</dd>
<dt>ccd<span class="classifier">str</span></dt><dd><p>the CCD(s) to transfer, ‘0’ for all of them. ‘1 3’, i.e.
separate with spaces for more than one CCD.</p>
</dd>
<dt>win<span class="classifier">str [hidden]</span></dt><dd><p>the window(s) to transfer, ‘0’ for all of them (default). The
same windows must exist in the selected CCDs of both inputs</p>
</dd>
<dt>output<span class="classifier">str</span></dt><dd><p>output file.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.stats">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">stats</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.stats" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">stats</span> <span class="pre">input</span> <span class="pre">[format]</span></code></p>
<p>Lists basic stats of a multi-CCD image, i.e. the minimum, maximum, mean,
median and standard deviation of each window of each CCD. The output
format can be altered to suit preference.</p>
<p>Parameters:</p>
<blockquote>
<div><dl class="simple">
<dt>input<span class="classifier">string</span></dt><dd><p>name of the MCCD file</p>
</dd>
<dt>format<span class="classifier">string [hidden, defaults to 9.3f]</span></dt><dd><p>C-style format code as used in Python format statements for output of
the numerical values. e.g. ‘300.00’ is ‘6.2f’ (6 characters toal, 2
after the decimal point), ‘1.22e24’ is ‘.2e’ (as many characters as
needed, 2 after the decimal point)</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.sub">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">sub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.sub" title="Link to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">sub</span> <span class="pre">input1</span> <span class="pre">input2</span> <span class="pre">[ccd</span> <span class="pre">win]</span> <span class="pre">output</span></code></p>
<p>Subtracts two hcm frames and outputs the result. Can be applied only to
particular CCDs and windows if wanted.</p>
<p>Parameters:</p>
<blockquote>
<div><dl class="simple">
<dt>input1<span class="classifier">string</span></dt><dd><p>first input hcm file</p>
</dd>
<dt>input2<span class="classifier">string</span></dt><dd><p>second input hcm file to subtract from the first.</p>
</dd>
<dt>ccd<span class="classifier">string [hidden, defaults to ‘all’]</span></dt><dd><p>the CCD or CCDs to apply the operation to. ‘all’ for the whole lot
which it returns to by default.  Can be several e.g. ‘2 4’ or just
one ‘3’</p>
</dd>
<dt>win<span class="classifier">string [hidden, defaults to ‘all’]</span></dt><dd><p>the CCD or CCDs to apply the operation to. ‘all’ for the whole lot
which it returns to by default.  Can be several e.g. ‘E2 G1’ or just
one ‘H1’. If you specify windows in this manner, it is assumed that
all the CCDs chosen in the previous input have the named windows;
‘all’ just applies the operation to all windows regardless.</p>
</dd>
<dt>output<span class="classifier">string</span></dt><dd><p>output hcm file name. Can be same as either input1 or input2
in which case the input file will be over-written.</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="hipercam.scripts.uls">
<span class="sig-prename descclassname"><span class="pre">hipercam.scripts.</span></span><span class="sig-name descname"><span class="pre">uls</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">args</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#hipercam.scripts.uls" title="Link to this definition">¶</a></dt>
<dd><p>Gives an ‘ls’-like listing of the runs available on the ULTRACAM file
server. Just invoke as ‘uls’ with no arguments.</p>
<p>See <a class="reference internal" href="#hipercam.scripts.hls" title="hipercam.scripts.hls"><code class="xref py py-func docutils literal notranslate"><span class="pre">hls</span></code></a> for the HiPERCAM equivalent.</p>
</dd></dl>

<aside class="footnote-list brackets">
<aside class="footnote brackets" id="f1" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>Several other commands (<code class="docutils literal notranslate"><span class="pre">aligntool</span></code>, <code class="docutils literal notranslate"><span class="pre">atanalysis</span></code>, <code class="docutils literal notranslate"><span class="pre">atbytes</span></code>,
<code class="docutils literal notranslate"><span class="pre">calsearch</span></code>, <code class="docutils literal notranslate"><span class="pre">harchive</span></code>, <code class="docutils literal notranslate"><span class="pre">hlogger</span></code>, <code class="docutils literal notranslate"><span class="pre">hmeta</span></code>, <code class="docutils literal notranslate"><span class="pre">logsearch</span></code>,
<code class="docutils literal notranslate"><span class="pre">makefield</span></code>, <code class="docutils literal notranslate"><span class="pre">makedata</span></code>, <code class="docutils literal notranslate"><span class="pre">pfolder</span></code>, <code class="docutils literal notranslate"><span class="pre">redplt</span></code>, <code class="docutils literal notranslate"><span class="pre">tanalysis</span></code>, <code class="docutils literal notranslate"><span class="pre">tbytes</span></code>)
are not documented here as they are of specialist usage.  Information
on these is however available via <code class="docutils literal notranslate"><span class="pre">pydoc</span></code>.</p>
</aside>
</aside>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper"><h3>Table of Contents</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="news.html">HiPERCAM pipeline news</a></li>
<li class="toctree-l1"><a class="reference internal" href="observers.html">Observer’s guide</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">HiPERCAM commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="api/api.html">The API</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Getting the software</a></li>
<li class="toctree-l1"><a class="reference internal" href="files.html">Useful files</a></li>
<li class="toctree-l1"><a class="reference internal" href="api/bugs.html">Reporting problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="makingmovies.html">Making HiPERCAM movies</a></li>
<li class="toctree-l1"><a class="reference internal" href="phaseII.html">HiPERCAM Phase II</a></li>
</ul>


  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="ultracam_checklist.html"
                          title="previous chapter">ULTRACAM observing checklist</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="api/api.html"
                          title="next chapter">The API</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/commands.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<form action="search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right">
    <a href="_sources/commands.rst.txt"
       rel="nofollow">Page Source</a> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2017, T.R. Marsh.<br/>
    Created using <a href="http://www.sphinx-doc.org/en/stable/">Sphinx</a> 7.4.7. &nbsp;
  </p>
</footer>
  </body>
</html>